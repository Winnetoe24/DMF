\documentclass[./einleitung.tex]{subfiles}
\usepackage{mdwtab}
\usepackage{makecell}
\usepackage{mdwtab}
\normalsize

\begin{document}
    \section{Der \acrshort{lsp}-Server}\label{sec:der-lsp-server}
    Der \acrshort{lsp}-Server besteht aus 3 Bereichen:
    \begin{enumerate}
        \item Dem Modell für das \acrlong{lsp}.
        \item Der Implementierung der Server-Schicht, welche die Kommunikation mit den Clients verwaltet und die Services aufruft.
        \item Die Service-Schicht, welche Funktionen des \acrshort{lsp}s in Services implementiert.
    \end{enumerate}

    In den folgenden Abschnitten werden der Aufbau, die Aufrufe und die Funktionen dieser Schichten erläutert.
    \subsection{Das \acrfull{lsp}}\label{subsec:das-acrfull{lsp}}\hypertarget{lsp-tech}
    % LSP Protokoll ist modular
    % Verschiedene Packages aufzählen
    Das \acrshort{lsp} wurde von Microsoft für die Verwendung in Visual Studio Code entwickelt. % TODO Quelle
    Es ermöglicht die Funktionen von Plugins über ein Protokoll zu transportieren. \\
    Das Protokoll nutzt JSON-RPC.
    Wie Nachrichten übermittelt werden, wird im Abschnitt \nameref{subsec:server-implementierung} beschrieben.
    \subsubsection{Grundlegende Nachrichten}
%! suppress = MissingLabel
    Im \acrshort{lsp} basieren alle Nachrichten auf dem Message-Interface.
    Deshalb beinhaltet jede Nachricht die JSON-RPC-Version auf der sie basiert.
    \begin{lstlisting}[language=Typescript,label={lst:lstlisting}]
interface Message {
	jsonrpc: string;
}
    \end{lstlisting}
    Die Nachrichten gehören zusätzlich zu einem der folgenden Typen:
    \paragraph{Anfragen}\textlf{\footnotesize Request-Message}\\
    \begin{lstlisting}[language=Typescript]
interface RequestMessage extends Message {

	/**
	 * The request id.
	 */
	id: integer | string;

	/**
	 * The method to be invoked.
	 */
	method: string;

	/**
	 * The method's params.
	 */
	params?: array | object;
}
    \end{lstlisting}
    Eine Anfrage wird genutzt, um das Ergebnis einer Methode anzufragen.\\
    Der Type der Parameter wird von der Methode festgelegt.
    Die Antwort wird zu der Anfrage mithilfe der ID zugeordnet.
    Diese ID wird von jedem Teilnehmer hochgezählt.

    \paragraph{Antwort}\textlf{\footnotesize Response-Message}\\
    \begin{lstlisting}[language=Typescript]
interface ResponseMessage extends Message {
	/**
	 * The request id.
	 */
	id: integer | string | null;

	/**
	 * The result of a request. This member is REQUIRED on success.
	 * This member MUST NOT exist if there was an error invoking the method.
	 */
	result?: LSPAny;

	/**
	 * The error object in case a request fails.
	 */
	error?: ResponseError;
}
    \end{lstlisting}
    Antworten werden immer nach einer Anfrage geschickt, selbst bei einem Fehler.\\
    Die meisten \acrshort{lsp}-Clients geben dem Server für die Antwort 5 Sekunden Zeit.\\
    Die ID beinhaltet die ID aus der Anfrage.\\
    Das Ergebnis(`result') existiert immer bei einer erfolgreichen Durchführung der Methode.
    Soll kein Wert zurückgegeben werden, so wird beim Ergebnis der Wert ``null'' gesetzt.\\
    Bei einem Fehler während der Ausführung der Methode muss der Fehler(`error') in der Antwort befüllt werden.
    \begin{lstlisting}[language=Typescript]
interface ResponseError {
	/**
	 * A number indicating the error type that occurred.
	 */
	code: integer;

	/**
	 * A string providing a short description of the error.
	 */
	message: string;

	/**
	 * A primitive or structured value that contains additional
	 * information about the error. Can be omitted.
	 */
	data?: LSPAny;
}
    \end{lstlisting}
    Der beinhaltet zwei wichtige Elemente: den Error-Code und die Error-Nachricht.
    Die Error-Codes sind vordefiniert vom Protokoll.\cite{response}
    Die Nachricht ist frei wählbar, sollte jedoch dem Nutzer erklären, wodurch der Fehler entstand.\\
    Es können zusätzliche Daten übermittelt werden.
    Jedoch ist das Format nicht definiert.
    Es bietet sich nur an dieses Element zu nutzen, wenn sowohl Server als auch Client selbst implementiert wurden.

    \paragraph{Benachrichtigungen}\textlf{\footnotesize Notification-Message}\\
\begin{lstlisting}[language=Typescript]
interface NotificationMessage extends Message {
	/**
	 * The method to be invoked.
	 */
	method: string;

	/**
	 * The notification's params.
	 */
	params?: array | object;
}
\end{lstlisting}
    Benachrichtigungen übermitteln Daten, ohne eine Antwort zu erwarten.
    Sie werden für z.B.\ den Abbruch einer Anfrage oder dem Übermitteln der aktuellen Fehler genutzt.\\
    Das Datenmodell einer Benachrichtigung unterscheidet sich von einer Anfrage nur durch die fehlende ID.


    \subsubsection{Der \acrshort{lsp}-Kommunikation-Lebenszyklus}
    Die Kommunikation eines Clients mit einem Server folgt einem Ablauf, welcher den Anfang und das Ende der Kommunikation definiert.
    Der Start eines Vorgangs im Lebenszyklus wird immer vom Client gestartet.
    %! suppress = MissingLabel
    \begin{center}
        \begin{sequencediagram}
            \newthread{c}{Client}{}
            \newthreadShift{s}{Server}{25em}

            \begin{sdblock}{Initialisierung}{Start der Kommunikation}
                \begin{call}{c}{initialize}{s}{}
                \end{call}
                \mess{s}{initialized}{c}{}
            \end{sdblock}

            \begin{sdblock}{Nutzung des Servers}{Inhalt der Kommunikation}
                \mess{c}{}{s}{}
                \mess{s}{}{c}{}
            \end{sdblock}

            \begin{sdblock}{Beenden des Servers}{Ende der Kommunikation}
                \begin{call}{c}{shutdowm}{s}{}
                \end{call}
                \mess{c}{exit}{s}{}
            \end{sdblock}
        \end{sequencediagram}
    \end{center}
    \paragraph{Initialisierung}\mbox{}\\
    Die Initialisierung umfasst die ersten Nachrichten, nachdem die Transportschicht die Verbindung etabliert hat. \\
    Sie beginnt mit dem Aufruf der Methode `initialize' des Servers.
    In den Parametern des Aufrufs werden die vom Client unterstützten Funktionen des \acrshort{lsp}s übermittelt.
    Der Server antwortet mit der Auswahl aus den vom Client gesendeten Funktionen, die auch der Server unterstützt.
    Die Unterstützung einer Funktion muss keine Entscheidungsfrage sein.
    Server und Client übermitteln auch wie sie Funktionen unterstützen.
    So können Client oder Server kommunizieren, dass sie z.B.\ die Veränderungen an einer Datei und/oder die vollständigen Dateien unterstützen.
    (Für genauere Informationen siehe Abschnitt \nameref{subsubsec:dokumenten-synchronisation})
    \newline
    \newline
    Nachdem die Feinheiten der Kommunikation bekannt sind, beginnt der Server mit den Vorbereitungen, um alle vereinbarten Funktionen verarbeiten zu können.
    Ist diese Vorbereitung abgeschlossen, sendet der Server die `initialized' Benachrichtigung.
    Nun ist der Start der Kommunikation ist erfolgreich abgeschlossen.


    \paragraph{Beenden des Servers}\mbox{}\\
    Wird der \acrshort{lsp}-Server nicht mehr vom Client benötigt, z.B.\ da keine relevanten Dateien mehr geöffnet sind oder die \acrshort{ide}/das Projekt geschlossen wird, so wird die Methode `shutdown' aufgerufen.
    Die Methode erwartet leere Parameter und beendet alle Strukturen für die Verarbeitung der \acrshort{lsp}-Funktionen.
    \\\\
    Sobald der Client die Kommunikation beendet, sendet er eine `exit'-Benachrichtigung.
    Hat der Server vorher eine `shutdown'-Anfrage erfolgreich beantwortet, so soll er mit dem Exit-Code 0 beenden.
    Ansonsten soll er sich mit dem Exit-Code 1 beenden.\\
    Der Exit-Code kann nur vom Client gelesen werden, wenn dieser den Prozess des Servers auch gestartet hat.

    \\\\
    In den folgenden Abschnitten werden die Funktionen die der \acrshort{dmf}-\acrshort{lsp}-Server unterstützt vorgestellt.

    \subsubsection[Anfragen stornieren]{Anfragen stornieren\\ {\textnormal{\footnotesize Cancelation Support (\$/cancelRequest) \cite{cancelation}}}}
    Der Client kann jederzeit entscheiden, dass das Ergebnis einer Anfrage nicht mehr benötigt wird.
    \begin{lstlisting}[language=Typescript,title=Definition der Parameter \cite{cancelation},label={lst:cancelParams}]
interface CancelParams {
	/**
	 * The request id to cancel.
	 */
	id: integer | string;
}
    \end{lstlisting}
    Die Parameter enthalten die ID der Anfrage, dessen Ergebnis nicht mehr benötigt wird.
    Der Server muss jedoch die Anfrage trotzdem noch beantworten, um dem Ablauf des Protokolls zu folgen.
    \\\\
    Diese Funktion wird im \namref{subsubsec:cancel-service} implementiert.

    \subsubsection[Dokumenten Synchronisation]{Dokumenten Synchronisation\\ {\textnormal{\footnotesize Text Document Synchronization \\ (textDocument/didOpen, textDocument/didChange, textDocument/didClose) \cite{dokumente}}}}\label{subsubsec:dokumenten-synchronisation}
    Damit ein \acrshort{lsp}-Server Aussagen über eine Datei oder ein ganzes Projekt treffen kann, muss der Server den aktuellen Stand der Dateien kennen.
    \\\\
    Während der Initialisierung wird vom Server festgelegt, ob das Öffnen und Schließen von Dateien an den Server übertragen und wie die Bearbeitungen an den Server übertragen werden sollen (gar nicht/komplette Datei/inkrementell).
    Der \acrshort{dmf}-\acrshort{lsp}-Server nutzt sowohl das Öffnen und Schließen der Dateien als auch die inkrementelle Übertragung der Bearbeitungen.
    \\\\
    Die Synchronisation beginnt, mit der Methode `textDocument/didOpen', welche beim Öffnen einer Datei ausgeführt wird.
    \begin{lstlisting}[language=Typescript,title=Definition der Parameter \cite{dokumente}, label=lst:dokumenteParams]
interface DidOpenTextDocumentParams {
	/**
	 * The document that was opened.
	 */
	textDocument: TextDocumentItem;
}
interface TextDocumentItem {
	/**
	 * The text document's URI.
	 */
	uri: DocumentUri;

	/**
	 * The text document's language identifier.
	 */
	languageId: string;

	/**
	 * The version number of this document (it will increase after each
	 * change, including undo/redo).
	 */
	version: integer;

	/**
	 * The content of the opened text document.
	 */
	text: string;
}
    \end{lstlisting}
    Die Parameter der Methode enthalten die \acrfull{uri}, den Inhalt der Datei, die Sprache und die Version.
    Von diesen Parametern sind die \acrshort{uri} und der Inhalt sehr bedeutend.
    Sie bestimmen welcher Inhalt unter welcher \acrshort{uri} vom Server gespeichert und verarbeitet wird.
    \\\\
    Nachdem ein Dokument geöffnet wurde, wird bei jeder Änderung die Methode `textDocument/didChange' aufgerufen.
    Die Parameter enthalten neben der \acrshort{uri} die Änderungen, welche die direkt in die Bearbeitungen der Treesitter-API übersetzt werden können.
    \begin{lstlisting}[language=Typescript, title=Definition der Bearbeitungen (ohne irrelevante Elemente)\cite{dokumente}, label=lst:dokumenteBearbeitung]
export type TextDocumentContentChangeEvent = {
	/**
	 * The range of the document that changed.
	 */
	range: Range;

	/**
	 * The new text for the provided range.
	 */
	text: string;
}
    \end{lstlisting}

    Wird eine Datei geschlossen, können im Server alle Ressourcen für die Datei freigegeben werden.
    Dafür ruft der Client die Methode `textDocument/didClose' auf.
    \\\\
    Die Funktionen für die Dokumenten Synchronization werden im \nameref{subsubsec:file-service} implementiert.

    \subsubsection[Referenzen bestimmen]{Referenzen bestimmen\\ {\textnormal{\footnotesize Go to Declaration \& Find References \\ (textDocument/declaration, textDocument/references) \cite{declaration} \cite{references}}}}\label{subsubsec:referenzen}
    Referenzen sind ein großer Teil des Typsystems des \acrshort{dmf}s.
    Damit diese Referenzen auch nachvollziehbar für die Entwickler*innen sind, bietet das \acrshort{lsp} mehrere Funktionen an.
    \paragraph{Die Deklaration eines Typs} kann mit der Methode `textDocument/declaration' abfragt werden.
    \begin{lstlisting}[language=Typescript, title=Definition der Parameter \cite{declaration}, caption=Definition der Deklarations-Parameter \cite{declaration}, label=lst:declarationParams]
export interface DeclarationParams extends TextDocumentPositionParams,
	WorkDoneProgressParams, PartialResultParams {
}
interface TextDocumentPositionParams {
	/**
	 * The text document.
	 */
	textDocument: TextDocumentIdentifier;

	/**
	 * The position inside the text document.
	 */
	position: Position;
}
    \end{lstlisting}
    Die Deklaration wird als LocationLink als Ergebnis bereitgestellt.
    \begin{lstlisting}[language=Typescript, title=Definition des LocationLink \cite{declaration}, label=lst:locationLink]
interface LocationLink {

	/**
	 * Span of the origin of this link.
	 *
	 * Used as the underlined span for mouse interaction. Defaults to the word
	 * range at the mouse position.
	 */
	originSelectionRange?: Range;

	/**
	 * The target resource identifier of this link.
	 */
	targetUri: DocumentUri;

	/**
	 * The full target range of this link. If the target for example is a symbol
	 * then target range is the range enclosing this symbol not including
	 * leading/trailing whitespace but everything else like comments. This
	 * information is typically used to highlight the range in the editor.
	 */
	targetRange: Range;

	/**
	 * The range that should be selected and revealed when this link is being
	 * followed, e.g the name of a function. Must be contained by the
	 * `targetRange`. See also `DocumentSymbol#range`
	 */
	targetSelectionRange: Range;
}
    \end{lstlisting}
    Ein LocationLink beschriebt einen Bereich in einem, auch vom aktuellem Dokument unterschiedlichem, Dokument.
    Dabei wird zwischen dem kompletten Bereich der Deklaration und dem Bereich welcher automatisch ausgewählt und in einer Auswahl angezeigt werden soll.

    \paragraph{Alle Referenzen zu einem Typ} können mit der Methode `textDocument/references' abgefragt werden.
    Zu den Referenzen gehören die Deklarationen und die Verwendung des Typs in Referenzen, Multireferenzen, Funktionen und Abstraktionen.\\
    Die Parameter unterscheiden sich von den der Deklaration nur im ReferenceContext.
    Dieser beinhaltet die Information, ob die Deklaration in der Antwort enthalten sein soll.
    \begin{lstlisting}[language=Typescript, title=Definition des ReferenceContext \cite{references}, label=lst:referenceContext]
export interface ReferenceContext {
	/**
	 * Include the declaration of the current symbol.
	 */
	includeDeclaration: boolean;
}
    \end{lstlisting}
    Im Ergebnis werden die Referenzen nicht in einem LocationLink zurückgegeben, sondern nur in einer Location.
    Diese Location enthält nur die \acrshort{uri} der Datei und den Bereich der Referenz.
    \begin{lstlisting}[language=Typescript, title=Definition der Location \cite{references}, label=lst:location]
interface Location {
	uri: DocumentUri;
	range: Range;
}
    \end{lstlisting}

    Die Beschreibung der Implementierung beider Methoden befindet sich im Abschnitt \nameref{subsubsec:reference-service}.

    \subsubsection[Hover-Effekt]{Hover-Effekt\\ {\textnormal{\footnotesize Hover (textDocument/hover) \cite{hover}}}}\label{subsubsec:hover}
    Das \acrshort{lsp} bietet die Funktion Informationen über ein Element bereitzustellen, wenn die Entwickler*innen über den Text ``hovern''.
    \\\\
    Während der Initialisierung gibt der Client die Formate an, die er für die Dokumentation unterstützt.
    Das \acrshort{lsp} beinhaltet zwei Formate in der Spezifikation: normaler Text und Mardown.
    \\\\
    Die Parameter der Anfrage erben von den TextDocumentPositionParams (siehe \nameref{lst:declarationParams}).
    Sie enthalten die \acrshort{uri} der Datei und die Position.\\
    Die Dokumentation wird zusammen mit einem optionalen Bereich übermittelt.
    \begin{lstlisting}[language=Typescript, caption=Definition des Hover Ergebnis \cite{hover}, label=lst:hover]
/**
 * The result of a hover request.
 */
export interface Hover {
	/**
	 * The hover's content
	 */
	contents: MarkedString | MarkedString[] | MarkupContent;

	/**
	 * An optional range is a range inside a text document
	 * that is used to visualize a hover, e.g. by changing the background color.
	 */
	range?: Range;
}
export interface MarkupContent {
	/**
	 * The type of the Markup
	 */
	kind: MarkupKind;

	/**
	 * The content itself
	 */
	value: string;
}
export type MarkupKind = 'plaintext' | 'markdown';
    \end{lstlisting}
    Die Implementierung des Hover-Effekts wird im Abschnitt \nameref{subsubsec:hover-service} beschrieben.

    \subsubsection[Faltbereich]{Faltbereich\\ {\textnormal{\footnotesize Folding Ranges (textDocument/foldingRange) \cite{folding}}}}\label{subsubsec:folding}
    Die Möglichkeit den Code in Abschnitte zu unterteilen und diese einfalten zu können, erleichtert die Übersicht in großen Dateien.
    Deshalb definiert das \acrshort{lsp} eine Funktion, um diese Bereiche an die \acrshort{ide} zu übermitteln.
    \\\\
    Während der Initialisierung kann der Client viele Vorgaben und Wünsche an den Server machen.
    Dazu zählen die gewünschte maximale Anzahl der Bereiche,
    ob nur komplette Zeilen gefaltet werden können,
    welche Falttypen unterstützt werden und ob vom Server generierte Zusammenfassungen angezeigt werden können.
    \\\\
    Die Anfrage an den Server beinhaltet nur die \acrshor{uri} der Datei.\\
    Die Antwort des Servers enthält eine Liste mit Faltbereichen.
    Die Faltbereiche decken die komplette Datei ab.
    Jeder Faltbereich enthält zusätzlich zur Startposition und Endposition auch den Falttypen und optional auch eine Zusammenfassung.
    \\\\
    Die Implementierung der Faltbereiche wird im Abschnitt \nameref{subsubsec:folding} beschrieben.

    \subsubsection[Auswahlbereich]{Auswahlbereich\\ {\textnormal{\footnotesize Selection Range (textDocument/selectionRange) \cite{selection}}}}\label{subsubsec:selection}
    Durch die unterschiedlichen Grammatiken aller Programmiersprachen ist eine Verallgemeinerung der Auswahlbereiche in einem Dokument unmöglich.
    Deshalb bietet das \acrshort{lsp} die Möglichkeit diese Bereiche vom Server abzufragen.
    \\\\
    Die Anfrage beinhaltet ein Dokument und verschiedene Positionen, zu denen die Auswahlbereiche erfragt werden.
    Der Vorteil von mehreren Positionen ist die Bündlung der Anfragen für Editoren mit mehreren Eingabemarken(Cursor).
    \begin{lstlisting}[language=Go, title=Auszug aus den Parametern, label=lst:selectionParams]
type SelectionRangeParams struct {
	// TextDocument identifies the document to compute selection ranges for.
	TextDocument protokoll.TextDocumentIdentifier `json:"textDocument"`

	// Positions is an array of positions in the text document for which to compute
	// selection ranges.
	Positions []protokoll.Position `json:"positions"`
}
    \end{lstlisting}
    Auswahlbereiche bilden einen Auszug aus dem \acrshort{ast}.
    Um eine Auswahl zu vergrößern oder zu verkleinern wird der höhere bzw.\ tiefere Auswahlbereich aus der Hierarchie des \acrshort{ast}s benötigt.
    Deshalb beinhaltet die Antwort im \acrshort{lsp} auch die Möglichkeit pro Position eine Kette an Auswahlbereichen zu liefern.
    Diese Kette wird durch das Parent-Attribut gebildet.
    \begin{lstlisting}[language=Go, title=Antwort des Servers, label=lst:selectionResult]
// SelectionRange represents a selection range with its parent selection ranges.
type SelectionRange struct {
	// Range is the actual range of this selection range.
	Range protokoll.Range `json:"range"`

	// Parent is the parent selection range containing this range. Therefore,
	// multiple selection ranges can be encoded into a tree structure.
	Parent *SelectionRange `json:"parent,omitempty"`
}

// SelectionRangeResult represents the result of a selection range request.
// It's an array of SelectionRange objects, one for each position in the request.
type SelectionRangeResult []SelectionRange
    \end{lstlisting}
    Die Implementierung der Auswahlbereiche wird im Abschnitt \nameref{subsubsec:selection-service} beschrieben.

    \subsubsection[Semantische Tokens]{Semantische Tokens\\ {\textnormal{\footnotesize Semantic Tokens (textDocument/semanticTokens/full) \cite{semantic}}}}\label{subsubsec:semantic}
    Um ein schnelles Verständnis einer Datei zu ermöglichen, ist die Einfärbung der Syntax und Semantik wichtig.
    Dafür stellt das \acrshort{lsp} die Möglichkeit bereit semantische Tokens/Symbole zu übermitteln.\\
    Ein Token bezieht sich immer auf einen Bereich im Sourcecode und übermittelt einen Tokentyp und eine Auswahl der Tokenmodifikatoren.
    Die Tokentypen und Tokenmodifikatoren werden während der Initialisierung übermittelt.
    Für jeden Token wird ein Tokentyp und eine Auswahl der Tokenmodifikatoren übermittelt.
    \\\\
    Für das \acrshort{dmf} wird nur die folgende Auswahl der Tokenmodifikatoren genutzt.
    \begin{center}
        \begin{tabular}{|c|c|}
            1 & declaration \\
            \hline
            2 & definition
        \end{tabular}
    \end{center}
    \paragraph{Die Tokentypen und ihre Verwendung zusammen mit den Tokenmodifikatoren}
    \begin{center}
        \begin{tabular}{|c|c|>{\centering\arraybackslash}m{\mycolwidth}|}
                \hline
                Index & Token Typ & \makecell{Verwendung im DMF \\
                \begin{tabular}{c|c}
                    Tokenmodifikator(-en) & Verwendung
                \end{tabular}}\tabularnewline
                \hline
                0 & namespace & \tablecell{declaration & Für den Namen eines Packages.}\\
                \hline
                1 & type & \tablecell{- &
                \makecell[l]{Für das AST-Element ``reftype''.\\Für den Override Wert des Java Typens.}
                }\\
                \hline
                2 & class & \tablecell{- & Für den Override Wert der Java Klasse, der Oberklasse und der implementierten Interfaces.}\\
                \hline
                3 & enum & \tablecell{ declaration &  Für den Namen eines Enums.}\\
                \hline
                4 & interface & \tablecell{ declaration & Für den Namen eines Interfaces.}\\
                \hline
                5 & struct & \tablecell{ declaration & Für den Namen eines Structs oder einer Entity.}\\
                \hline
                6 & parameter & \tablecell{ declaration & Für die Parameter einer Funktion. }\\
                \hline
                7 & variable &
                \tablecell{
                    - & Für die Namen der Variablen im Entity Identifier. Für den Override Wert des Java Namens.\\
                    \hline
                    declaration & Für die Namen von Argumenten, Referenzen und MultiReferenzen.\\
                }\\
                \hline
                8 & property & Platzhalter\\
                \hline
                9 & number & \tablecell{ definition & Für alle Zahlenwerte in einer Enum-Konstante. }\\
                \hline
                10 & enumMember & \tablecell{ declaration & Für den Namen einer Enum-Konstante. }\\
                \hline
                11 & function & \tablecell{ declaration & Für den Namen einer Funktion. }\\
                \hline
                12 & comment & \tablecell{ - & Für alle Kommentare.}\\
                \hline
                13 & keyword & \tablecell{ - & Für alle Keywords.}\\
                \hline
                14 & string & \tablecell{ - & Für alle Strings außer den Werten im Override. }\\
                \hline
                15 & modifier & Platzhalter\\
                \hline
                16 & decorator & \tablecell{ - & Für den Override Wert der Java Annotations. }\\
                \hline
            \end{tabular}
    \end{center}
    \\\\
    Wenn die neuen semantischen Tokens übermittelt werden, werden die Tokens mithilfe einer Zahlenfolge codiert.
    \begin{center}
        \begin{tabular}{| c | c | m{21.5em} |}
            \hline
            \makecell{Index in der\\ Zahlenfolge\\für Token mit \\Index i} & Name & Erklärung \\
            \hline
            5*i & deltaLine & Die Zeilen zwischen dem letzten Token und diesem Token. \\
            \hline
            5*i+1 & deltaStart & Die Zeichen zwischen dem letzten Token und diesem Token.
            Relativ zu 0, falls der aktuelle Token in einer neuen Zeile ist. \\
            \hline
            5*i+2 & length & Die Länge des Tokens. \\
            \hline
            5*i+3 & tokenType & Index des Typs des Tokens in der Semantik Token Typ Legende. \\
            \hline
            5*i+4 & tokenModifiers & Zahl deren Bits als Wahrheitswerte für jeden Modifikator aus der Legende der Semantik Token Modifikatoren.
            Der erste Bit (0b00000001) steht dabei für den ersten Modifikator. \\
            \hline
        \end{tabular}
    \end{center}
    \subsection{Server Implementierung}\label{subsec:server-implementierung}
    % Wie funktioniert JSON-RPC
    % Wie parsed Golang json
    % Wie werden Service Aufgerufen
       TODO
    \subsubsection{Abstraktion der Server-Client-Verbindung}
    Da das \acrshort{lsp} Medium unabhängig ist, muss der Server eine Abstraktion für die Verbindung bereitstellen.
    \begin{lstlisting}[language=Go]
package connect
type Connection interface {
	// WriteMessage Writes Message.
    // May queue the Message the syncronise the Writing
	WriteMessage(message protokoll.Message)

	// WaitForMessage Waits for the next Message
    // and returns the Message or the error.
	// Call to this method blocks execution.
	WaitForMessage() (protokoll.Message, error)

	BlockResponse(id json.RawMessage)
	Close() error
}
    \end{lstlisting}
    Das Interface Connection stellt diese Abstraktion bereit.
    Es wird für jeden Verbindungstyp implementiert.

    % Wie funktioniert die Kommunikation über HTTP
    \subsection{Die \acrshort{lsp}-Services}
    Die Schnittstelle für alle Services zu der Server-Schicht bildet das MethodHandler-Interface:
    \begin{lstlisting}[language=Go]
package service
type MethodHandler interface {
	Initialize(params *initialize.InitializeParams,
                result *initialize.InitializeResult)
	GetMethods() []string
	HandleMethod(message protokoll.Message)
}
    \end{lstlisting}
    Jeder Service implementiert die drei Methoden.
    \begin{enumerate}
        \item \textbf{Initialize} \\
        Der Service liest die Fähigkeiten des Clients und konfiguriert sich selbständig.
        Sollte der Client den Service nicht unterstützen, muss er sich deaktivieren.
        Der Service schreibt seine Fähigkeiten in die Antwort des Servers.
        \item \textbf{GetMethods} \\
        Gibt die Methoden aus dem \acrshort{lsp} zurück für die der Service Meldungen verarbeitet.
        \item \textbf{HandleMethod} \\
        Verarbeite die Nachricht.
    \end{enumerate}


    \subsubsection{FileService}\label{subsubsec:file-service}
    Der FileService ist die Schnittstelle zwischen den Dateien, den Parsern und den restlichen Services.
    Wenn ein anderer Service auf Dateien, semantische Modell oder den Lookup zugreifen möchte, werden Methoden des FileServices genutzt.
    \begin{lstlisting}[language=Go]
package fileService
type FileService struct {
	handleMap map[string]*fileHandle
	listeners []FileChangeListener
	con       connect.Connection
}
    \end{lstlisting}
    In der ``handleMap'' werden ``fileHandles'' gespeichert.
    Ein FileHandle speichert alle Daten zu einer Datei und wird mit jeder Veränderung aktualisiert.
    \begin{lstlisting}[language=Go]
package fileService
type fileHandle struct {
	FileContent string
	Ast         *tree_sitter.Tree
	Model       *smodel.Model
	LookUp      *smodel.TypeLookUp
	Version     int32
}
    \end{lstlisting}
    Um einen FileHandle zu erzeugen, wird der Inhalt der Datei mithilfe Semantik-Schicht geparst.\\
    Wird der Dateiinhalt geändert, so werden die Änderungen an die Semantik-Schicht übergeben.
    Dort werden die Änderungen zum iterativen Parsen des neuen Dateiinhalts genutzt.
    Abschließend werden der Lookup erzeugt und die semantischen Regeln durchlaufen. \\
    \paragraph{FileChangeListener}
    Es gibt Funktionen im \acrshort{lsp} die nicht durch eingehende Nachrichten ausgelöst werden, sondern nach Dateiänderungen automatisch an den Client übermittelt werden.
    Dafür gibt es im \acrshort{dmf}-\acrshort{lsp}-Server die FileChangeListener.
    \begin{lstlisting}[language=Go]
package fileService
type FileChangeListener interface {
	// HandleFileChange gets called when the FileService
    // finishes parsing the File.
    // It may be called in its own routine.
    // Changes to the Parameters are ignored.
	HandleFileChange(file protokoll.DocumentURI, fileContent string,
                    ast *tree_sitter.Tree, model *smodel.Model,
                    lookup smodel.TypeLookUp,
                    errorElements []errElement.ErrorElement,
                    version int32)
}
    \end{lstlisting}
    Der FileService enthält Referenzen zu allen aktiven Listener.
    Nachdem ein FileHandle erstellt oder bearbeitet wurde, werden alle Listener durchlaufen.\\
    Im \acrshort{dmf}-\acrshort{lsp}-Server ist nur ein FileChangeListener implementiert:
    \subparagraph{Der DiagnosticsService}
    übermittelt die aktuellen Fehler in der Modelldatei an den Client.
    Dafür werden alle ErrorElemente in die Diagnostic Strukturen des \acrshort{lsp}s übersetzt.
    Schließlich werden die Daten mithilfe einer Request-Nachricht für die Methode ``textDocument/publishDiagnostics'' an den Client übermittelt.

    \subsubsection{SemanticTokensService}\label{subsubsec:semantic-service}
    Um ein schnelles Verständnis einer Datei zu ermöglichen, ist die Einfärbung der Syntax und Semantik wichtig.
    Dafür stellt das \acrshort{lsp} die Möglichkeit bereit semantische Tokens zu übermitteln.\\
    Ein Token bezieht sich immer auf einen Bereich im Sourcecode und übermittelt einen Tokentyp und eine Auswahl der Tokenmodifikatoren.
    Die Tokentypen und Tokenmodifikatoren werden während der Initialisierung übermittelt.
    Der Client kann auch während der Initialisierung angeben, ob überlappende Bereich für Token unterstützt werden.
    Wenn die neuen semantischen Tokens übermittelt werden, werden die Tokens mithilfe einer Zahlenfolge codiert.



    \paragraph{Der Legende für Semantik Token Typen}
    \begin{center}
        \begin{tabular}{|c|c|p{\mycolwidth}|}
            \hline
            Index & Token Typ & Verwendung im DMF \\
            \hline
            0 & namespace & Für den Namen eines Packages.\\
            \hline
            1 & type & \makecell[l]{Für das AST-Element ``reftype''.\\Für den Override Wert des Java Typens.}\\
            \hline
            2 & class & Für den Override Wert der Java Klasse, der Oberklasse und der implementierten Interfaces.\\
            \hline
            3 & enum & Für den Namen eines Enums.\\
            \hline
            4 & interface & Für den Namen eines Interfaces.\\
            \hline
            5 & struct & Für den Namen eines Structs oder einer Entity.\\
            \hline
            6 & parameter & Für die Parameter einer Funktion.\\
            \hline
            7 & variable & \makecell[l]{Für die Namen von Argumenten, Referenzen und \\MultiReferenzen.\\Für die Namen der Variablen im Entity Identifier.\\Für den Override Wert des Java Namens.}\\
            \hline
            8 & property &\\
            \hline
            9 & number & Für alle Zahlenwerte in einer Enum-Konstante.\\
            \hline
            10 & enumMember & Für den Namen einer Enum-Konstante.\\
            \hline
            11 & function & Für den Namen einer Funktion.\\
            \hline
            12 & comment & Für alle Kommentare.\\
            \hline
            13 & keyword & Für alle Keywords.\\
            \hline
            14 & string & Für alle Strings außer den Werten im Override.\\
            \hline
            15 & modifier & \\
            \hline
            16 & decorator & Für den Override Wert der Java Annotations.\\
            \hline
        \end{tabular}
    \end{center}
%TODO Modifier
    \paragraph{Generierung der Semantik Tokens}\mbox{}\\
    Die Semantik Tokens werden mithilfe zweier Algorithmen generiert.
    \subparagraph{Mithilfe des \acrshort{ast}s} werden alle \acrshort{ast}-Elemente durchlaufen.
    Werden Elemente erreicht, deren semantischer Token allein am \acrshort{ast} Element bestimmt werden kann, so werden die Token generiert.
    \subparagraph{Mithilfe des semantischen Modells} werden die restlichen Token bestimmt.
    Dies ist möglich da die Elemente im semantischen Modell Referenzen zum \acrshort{ast} beinhalten.
    Dazu gehören die Namen der verschiedenen Inhalte, wie z.B.\ von Argumenten.
    Bei diesen Namen wird das gleiche \acrshort{ast}-Element genutzt, wodurch sie nur das semantische Parsen unterscheidbar sind.

    \subparagraph{Die Codierung der semantischen Tokens} muss zunächst die generierten Tokens sortieren, da keine Garantie für die richtige Reihenfolge durch die beiden Algorithmen existiert.
    \begin{lstlisting}[language=Go,label={lst:sortSemanticTokens}]
slices.SortFunc(semanticElements, func(a, b *semanticElement) int {
    if a.line == b.line {
        return cmp.Compare(a.start, b.start)
    }
    return cmp.Compare(a.line, b.line)
})
    \end{lstlisting}
    Nach der Sortierung können die Tokens durchlaufen werden.
    \begin{lstlisting}[language=Go]
data := make([]uint32, len(semanticElements)*5)

lastLine := uint32(0)
lastStart := uint32(0)

for i, element := range semanticElements {
    line := element.line
    start := element.start
    length := element.length
    tokenType := element.tokenType
    tokenModifiers := element.tokenModifiers
    if line < lastLine {
        // Tokens must be sorted by line and character
        continue
    }

    if line == lastLine && start < lastStart {
        // Tokens must be sorted by line and character
        continue
    }

    // Calculate delta encoding
    deltaLine := line - lastLine
    deltaStart := uint32(0)
    if line == lastLine {
        deltaStart = start - lastStart
    } else {
        deltaStart = start
    }

    data[i*5] = deltaLine
    data[i*5+1] = deltaStart
    data[i*5+2] = length
    data[i*5+3] = tokenType
    data[i*5+4] = tokenModifiers

    lastLine = line
    lastStart = start
}
    \end{lstlisting}
    Beim Durchlaufen wird ein Integer-Slice erstellt. \\
    Für jeden Token werden die 5 Zahlen nach dem Protokoll hinzugefügt. \\
    Überschneiden sich Token oder sind nicht in der richtigen Reihenfolge werden die Token ignoriert. \\
    Die aktuelle Zeile und Spalte im Text wird nach jedem Token aktualisiert.

    \subsubsection{SelectionRangeService}\label{subsubsec:selection-service}
    Der SelectionRangeService implementiert die \acrshort{lsp}-Methode ``textDocument/selectionRange''.
    Diese wird dafür genutzt, dass bei der Auswahl immer der richtige Text ausgewählt wird. \\
    Die Bereiche werden im Service mithilfe des \acrshort{ast}s berechnet.
    \begin{lstlisting}[language=Go]
package selectionRangeService
func (s *SelectionRangeService) computeSelectionRangeForPosition(
        content fileService.FileContent,
        position protokoll.Position) *selectionRange.SelectionRange {
	finder := util.NewNodeFinder([]byte(content.Content))
	node := finder.FindSmallestNodeAroundPosition(content.Ast, position)
	var currentRange *selectionRange.SelectionRange
	for node != nil {
		newRange := &selectionRange.SelectionRange{
			Range: protokoll.ToRange(node.Range()),
		}
		newRange.Parent = currentRange
		currentRange = newRange

		node = node.Parent()
	}
	return currentRange
}
    \end{lstlisting}
    Es wird zunächst das kleinste Element(das ``Blatt'' des Baums) des \acrshort{ast}s für die Position Code bestimmt.\\
    Nun wird durch die Schichten des \acrshort{ast}s bis zur Wurzel iteriert.
    Bei jedem Element eine neue ``SelectionRange'' Instanz  angelegt.
    Dieses ``SelectionRange'' enthält immer den Bereich und eine Referenz zu der vorherigen ``SelectionRange''.
    Durch die Referenz wird die Baum-Struktur auch im Ergebnis übermittelt und es müssen weniger Anfragen an den Server gesendet werden.\\

    Ein Request kann mehrere Positionen enthalten.
    Deshalb wird der Algorithmus für jede Position ausgeführt.
\end{document}