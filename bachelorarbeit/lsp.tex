\documentclass[./einleitung.tex]{subfiles}

\begin{document}
    \section{Der \acrshort{lsp}-Server}\label{sec:der-lsp-server}
    Der \acrshort{lsp}-Server besteht aus 3 Bereichen:
    \begin{enumerate}
        \item Dem Modell für das \acrlong{lsp}.
        \item Der Implementierung der Server-Schicht, welche die Kommunikation mit den Clients verwaltet und die Services aufruft.
        \item Die Service-Schicht, welche Funktionen des \acrshort{lsp}s in Services implementiert.
    \end{enumerate}

    In den folgenden Abschnitten werden der Aufbau, die Aufrufe und die Funktionen dieser Schichten erläutert.
    \subsection{Das \acrfull{lsp}}\label{subsec:das-acrfull{lsp}}\hypertarget{lsp-tech}
    % LSP Protokoll ist modular
    % Verschiedene Packages aufzählen
    Das \acrshort{lsp} wurde von Microsoft für die Verwendung in Visual Studio Code entwickelt. % TODO Quelle
    Es ermöglicht die Funktionen von Plugins über ein Protokoll zu transportieren. \\
    Das Protokoll nutzt JSON-RPC.
    Wie Nachrichten übermittelt werden, wird im Abschnitt \nameref{subsec:server-implementierung} beschrieben.
    \subsubsection{Grundlegende Nachrichten}
%! suppress = MissingLabel
    Im \acrshort{lsp} basieren alle Nachrichten auf dem Message-Interface.
    Deshalb beinhaltet jede Nachricht die JSON-RPC-Version auf der sie basiert.
    \begin{lstlisting}[language=Typescript,label={lst:lstlisting}]
interface Message {
	jsonrpc: string;
}
    \end{lstlisting}
    Die Nachrichten gehören zusätzlich zu einem der folgenden Typen (vgl.~\cite{lsp}):
    \paragraph{Anfragen}{\footnotesize Request-Message\\}
    \begin{lstlisting}[language=Typescript]
interface RequestMessage extends Message {
	id: integer | string;
	method: string;
	params?: array | object;
}
    \end{lstlisting}
    Eine Anfrage wird genutzt, um das Ergebnis einer Methode anzufragen.\\
    Der Type der Parameter wird von der Methode festgelegt.
    Die Antwort wird zu der Anfrage mithilfe der ID zugeordnet.
    Diese ID wird von jedem Teilnehmer hochgezählt.

    \paragraph{Antwort}{\footnotesize Response-Message}\\
    \begin{lstlisting}[language=Typescript]
interface ResponseMessage extends Message {
	id: integer | string | null;
	result?: LSPAny;
	error?: ResponseError;
}
    \end{lstlisting}
    Antworten werden immer nach einer Anfrage geschickt, selbst bei einem Fehler.\\
    Die meisten \acrshort{lsp}-Clients geben dem Server für die Antwort 5 Sekunden Zeit.\\
    Die ID beinhaltet die ID aus der Anfrage.\\
    Das Ergebnis (`result') existiert immer bei einer erfolgreichen Durchführung der Methode.
    Soll kein Wert zurückgegeben werden, so wird beim Ergebnis der Wert ``null'' gesetzt.\\
    Bei einem Fehler während der Ausführung der Methode muss der Fehler (`error') in der Antwort befüllt werden.
    \begin{lstlisting}[language=Typescript]
interface ResponseError {
	code: integer;
	message: string;
	data?: LSPAny;
}
    \end{lstlisting}
    Der beinhaltet zwei wichtige Elemente: den Error-Code und die Error-Nachricht.
    Die Error-Codes sind vordefiniert vom Protokoll (siehe~\cite{response}).
    Die Nachricht ist frei wählbar, sollte jedoch dem Nutzer erklären, wodurch der Fehler entstand.\\
    Es können zusätzliche Daten übermittelt werden.
    Jedoch ist das Format nicht definiert.
    Es bietet sich nur an dieses Element zu nutzen, wenn sowohl Server als auch Client selbst implementiert wurden.

    \paragraph{Benachrichtigungen}{\footnotesize Notification-Message}\\
\begin{lstlisting}[language=Typescript]
interface NotificationMessage extends Message {
	method: string;
	params?: array | object;
}
\end{lstlisting}
    Benachrichtigungen übermitteln Daten, ohne eine Antwort zu erwarten.
    Sie werden für z.B.\ den Abbruch einer Anfrage oder dem Übermitteln der aktuellen Fehler genutzt.\\
    Das Datenmodell einer Benachrichtigung unterscheidet sich von einer Anfrage nur durch die fehlende ID.


    \paragraph{In Modell des \acrshort{dmf}-\acrshort{lsp}-Servers} werden die verschiedenen Nachrichten in einer Struktur zusammengefasst.
    Der Typ der Nachricht wird dabei anhand der mit Werten befüllten Variablen bestimmt.\\
    Damit bei der Verarbeitung der Nachricht der Typ der Parameter anhand der Methode bestimmt werden kann, enthält die Variable Params nur einen Wert von Typ `json.RawMessage'.
    Das Parsen der Parameter wird im zugeordneten Service durchgeführt.\\
    Die ID wird auch nicht direkt zu einer Zahl geparsed, da die sowohl als Zahl als auch als String übermittelt werden kann.\\
    Zur Abstraktion des Ergebnisses wird ein allgemeines Interfaces als Typ definiert, welches jede Datenstruktur in Go implementiert.
    \begin{lstlisting}[language=Go, caption=Definition der Nachricht im Go-Modell, label=lst:messageGo]
type Message struct {
	// JsonRPC ist die Version des Protokolls → 2.0
	JsonRPC string `json:"jsonrpc"`
	// ID des Requests. Wird auch von Responses mit der ID des Requests befüllt.
	ID json.RawMessage `json:"id,omitempty"`
	// Method die aufgerufen wird. Nur Teil von Requests und Notifications.
	Method string `json:"method,omitempty"`
	// Params sind Teil von Requests und Notifications.
	// Sie werden in den entsprechenden Services geparst.
	Params json.RawMessage `json:"params,omitempty"`
	// Result wird nur bei erfolgreichen Responses mit der Antwort befüllt.
	Result interface{} `json:"result,omitempty"`
	// Error wird nur bei fehlgeschlagenen Responses befüllt.
	Error *Error `json:"error,omitempty"`
}
    \end{lstlisting}


    \subsubsection{Der \acrshort{lsp}-Kommunikation-Lebenszyklus}
    Die Kommunikation eines Clients mit einem Server folgt einem Ablauf, welcher den Anfang und das Ende der Kommunikation definiert.
    Der Start eines Vorgangs im Lebenszyklus wird immer vom Client gestartet.
    %! suppress = MissingLabel
    \begin{center}
        \begin{sequencediagram}
            \newthread{c}{Client}{}
            \newthreadShift{s}{Server}{25em}

            \begin{sdblock}{Initialisierung}{Start der Kommunikation}
                \begin{call}{c}{initialize}{s}{}
                \end{call}
                \mess{s}{initialized}{c}{}
            \end{sdblock}

            \begin{sdblock}{Nutzung des Servers}{Inhalt der Kommunikation}
                \mess{c}{}{s}{}
                \mess{s}{}{c}{}
            \end{sdblock}

            \begin{sdblock}{Beenden des Servers}{Ende der Kommunikation}
                \begin{call}{c}{shutdown}{s}{}
                \end{call}
                \mess{c}{exit}{s}{}
            \end{sdblock}
        \end{sequencediagram}
    \end{center}
    \paragraph{Initialisierung}\mbox{}\\
    Die Initialisierung umfasst die ersten Nachrichten, nachdem die Transportschicht die Verbindung etabliert hat. \\
    Sie beginnt mit dem Aufruf der Methode `initialize' des Servers.
    In den Parametern des Aufrufs werden die vom Client unterstützten Funktionen des \acrshort{lsp}s übermittelt.
    Der Server antwortet mit der Auswahl aus den vom Client gesendeten Funktionen, die auch der Server unterstützt.
    Die Unterstützung einer Funktion muss keine Entscheidungsfrage sein.
    Server und Client übermitteln auch, wie sie Funktionen unterstützen.
    So können Client oder Server kommunizieren, dass sie z.B.\ die Veränderungen an einer Datei und/oder die vollständigen Dateien unterstützen.
    (Für genauere Informationen siehe Abschnitt \nameref{subsubsec:dokumenten-synchronisation})
    \newline
    \newline
    Nachdem die Feinheiten der Kommunikation bekannt sind, beginnt der Server mit den Vorbereitungen, um alle vereinbarten Funktionen verarbeiten zu können.
    Ist diese Vorbereitung abgeschlossen, sendet der Server die `initialized' Benachrichtigung.
    Nun ist der Start der Kommunikation erfolgreich abgeschlossen.


    \paragraph{Beenden des Servers}\mbox{}\\
    Wird der \acrshort{lsp}-Server nicht mehr vom Client benötigt, z.B.\ da keine relevanten Dateien mehr geöffnet sind oder die \acrshort{ide}/das Projekt geschlossen wird, so wird die Methode `shutdown' aufgerufen.
    Die Methode erwartet leere Parameter und beendet alle Strukturen für die Verarbeitung der \acrshort{lsp}-Funktionen.
    \\\\
    Sobald der Client die Kommunikation beendet, sendet er eine `exit'-Benachrichtigung.
    Hat der Server vorher eine `shutdown'-Anfrage erfolgreich beantwortet, so soll er mit dem Exit-Code 0 beenden.
    Ansonsten soll er sich mit dem Exit-Code 1 beenden.\\
    Der Exit-Code kann nur vom Client gelesen werden, wenn dieser den Prozess des Servers auch gestartet hat.
    \\\\
    In den folgenden Abschnitten werden die Funktionen, die der \acrshort{dmf}-\acrshort{lsp}-Server unterstützt, vorgestellt.

    \subsubsection[Anfragen stornieren]{Anfragen stornieren\\ {\textnormal{\footnotesize Cancelation Support (\$/cancelRequest) \cite{cancelation}}}} \label{subsubsec:cancel}
    Der Client kann jederzeit entscheiden, dass das Ergebnis einer Anfrage nicht mehr benötigt wird.
    \begin{lstlisting}[language=Go,title=Definition der Parameter,label={lst:cancelParams}]
type CancelParams struct {
	ID json.RawMessage `json:"id"`
}
    \end{lstlisting}
    Die Parameter enthalten die ID der Anfrage, dessen Ergebnis nicht mehr benötigt wird.
    Der Server muss jedoch die Anfrage trotzdem noch beantworten, um dem Ablauf des Protokolls zu folgen.
    \\\\
    Diese Funktion wird im Abschnitt \nameref{subsubsec:cancel-service} implementiert.

    \subsubsection[Dokumentensynchronisation]{Dokumentensynchronisation\\ {\textnormal{\footnotesize Text Document Synchronization \\ (textDocument/didOpen, textDocument/didChange, textDocument/didClose) \cite{dokumente}}}}\label{subsubsec:dokumenten-synchronisation}
    Damit ein \acrshort{lsp}-Server Aussagen über eine Datei oder ein ganzes Projekt treffen kann, muss der Server den aktuellen Stand der Dateien kennen.
    \\\\
    Während der Initialisierung wird vom Server festgelegt, ob das Öffnen und Schließen von Dateien an den Server übertragen und wie die Bearbeitungen an den Server übertragen werden sollen (gar nicht/komplette Datei/inkrementell).
    Der \acrshort{dmf}-\acrshort{lsp}-Server nutzt sowohl das Öffnen und Schließen der Dateien als auch die inkrementelle Übertragung der Bearbeitungen.
    \\\\
    Die Synchronisation beginnt, mit der Methode `textDocument/didOpen', welche beim Öffnen einer Datei ausgeführt wird.
    \begin{lstlisting}[language=Go,title=Definition der Parameter aus zwei Packages, label=lst:dokumenteParams]
package textEdit
type DidOpenTextDocumentParams struct {
	TextDocument protokoll.TextDocumentItem `json:"textDocument"`
}
package protokoll
type TextDocumentItem struct {
	URI        DocumentURI `json:"uri"`
	LanguageID string      `json:"languageId"`
	Version    int32       `json:"version"`
	Text       string      `json:"text"`
}
    \end{lstlisting}
    Die Parameter der Methode enthalten die \acrfull{uri}, den Inhalt der Datei, die Sprache und die Version.
    Von diesen Parametern sind die \acrshort{uri} und der Inhalt sehr bedeutend.
    Sie bestimmen welcher Inhalt unter welcher \acrshort{uri} vom Server gespeichert und verarbeitet wird.
    \\\\
    Nachdem ein Dokument geöffnet wurde, wird bei jeder Änderung die Methode `textDocument/didChange' aufgerufen.
    Die Parameter enthalten neben der \acrshort{uri} die Änderungen, welche direkt in die Bearbeitungen der Treesitter-API übersetzt werden können.
    \begin{lstlisting}[language=Go, title=Definition der Bearbeitungen, label=lst:dokumenteBearbeitung]
type TextDocumentContentChangeEvent struct {
	Range       *protokoll.Range `json:"range,omitempty"`
	RangeLength uint32           `json:"rangeLength,omitempty"`
	Text        string           `json:"text"`
}
    \end{lstlisting}

    Wird eine Datei geschlossen, können im Server alle Ressourcen für die Datei freigegeben werden.
    Dafür ruft der Client die Methode `textDocument/didClose' auf.
    \\\\
    Die Funktionen für die Dokumentensynchronization werden im \nameref{subsubsec:file-service} implementiert.

    \subsubsection[Referenzen bestimmen]{Referenzen bestimmen\\ {\textnormal{\footnotesize Go to Declaration \& Find References \\ (textDocument/declaration, textDocument/references) \cite{declaration} \cite{references}}}}\label{subsubsec:referenzen}
    Referenzen sind ein großer Teil des Typsystems des \acrshort{dmf}s.
    Damit diese Referenzen auch nachvollziehbar für die Entwickler*innen sind, bietet das \acrshort{lsp} mehrere Funktionen an.
    \paragraph{Die Deklaration eines Typs} kann mit der Methode `textDocument/declaration' abgefragt werden.
    \begin{lstlisting}[language=Go, title=Definition der Parameter, caption=Definition der Deklarations-Parameter, label=lst:declarationParams]
type DeclarationParams struct {
	TextDocument protokoll.TextDocumentIdentifier `json:"textDocument"`
	Position protokoll.Position `json:"position"`
}
    \end{lstlisting}
    Die Deklaration wird als DeclarationLink als Ergebnis bereitgestellt.
    \begin{lstlisting}[language=Go, title=Definition des DeclarationLink , label=lst:locationLink]
type DeclarationLink struct {
	Origin *protokoll.Range `json:"originSelectionRange,omitempty"`
	TargetURI            string          `json:"targetUri"`
	TargetRange          protokoll.Range `json:"targetRange"`
	TargetSelectionRange protokoll.Range `json:"targetSelectionRange"`
}
    \end{lstlisting}
    Ein DeclarationLink beschreibt einen Bereich in einem, auch vom aktuellem Dokument unterschiedlichen, Dokument.
    Dabei wird zwischen dem kompletten Bereich der Deklaration und dem Bereich welcher automatisch ausgewählt und in einer Auswahl angezeigt werden soll, unterschieden.

    \paragraph{Alle Referenzen zu einem Typ} können mit der Methode `textDocument/references' abgefragt werden.
    Zu den Referenzen gehören die Deklarationen und die Verwendung des Typs in Referenzen, Multireferenzen, Funktionen und Abstraktionen.\\
    Die Parameter unterscheiden sich von den der Deklaration nur im ReferenceContext.
    Dieser beinhaltet die Information, ob die Deklaration in der Antwort enthalten sein soll.
    \begin{lstlisting}[language=Go, title=Definition des ReferenceContext, label=lst:referenceContext]
type ReferenceContext struct {
	IncludeDeclaration bool `json:"includeDeclaration"`
}
    \end{lstlisting}
    Im Ergebnis werden die Referenzen nicht in einem LocationLink zurückgegeben, sondern nur in einer Location.
    Diese Location enthält nur die \acrshort{uri} der Datei und den Bereich der Referenz.
    \begin{lstlisting}[language=Go, title=Definition der Location, label=lst:location]
type Location struct {
	URI   DocumentURI `json:"uri"`
	Range Range       `json:"range"`
}
    \end{lstlisting}

    Die Beschreibung der Implementierung beider Methoden befindet sich im Abschnitt \nameref{subsubsec:reference-service}.\\
    Die Benutzung der Referenzen wird im Abschnitt \nameref{subsubsec:useReferenzen} (\ref{subsubsec:useReferenzen}) beschrieben.


    \subsubsection[Hover-Effekt]{Hover-Effekt\\ {\textnormal{\footnotesize Hover (textDocument/hover) \cite{hover}}}}\label{subsubsec:hover}
    Das \acrshort{lsp} bietet die Funktion Informationen über ein Element bereitzustellen, wenn die Entwickler*innen mit ihrer Maus über den Text ``hovern''.
    \\\\
    Während der Initialisierung gibt der Client die Formate an, die er für die Dokumentation unterstützt.
    Das \acrshort{lsp} beinhaltet zwei Formate in der Spezifikation: normaler Text und Markdown.
    \\\\
    Die Parameter enthalten die \acrshort{uri} der Datei und die Position.
    \begin{lstlisting}[language=Go, caption=Definition der Hover Parameter, label=lst:hoverParams]
type HoverParams struct {
	TextDocument protokoll.TextDocumentIdentifier `json:"textDocument"`
	Position protokoll.Position `json:"position"`
}
    \end{lstlisting}
    Die Dokumentation wird zusammen mit einem optionalen Bereich übermittelt.
    Das Ergebnis kann verschiedene Typen beinhalten, weshalb der Inhalt der Nachricht schon vorzeitig geparsed wird.
    \begin{lstlisting}[language=Go, caption=Definition des Hover Ergebnis, label=lst:hover]
type HoverResult struct {
    // Kann []MarkupContent, MarkupContent oder MarkedString beinhalten.
	Contents json.RawMessage `json:"contents"`
	Range *protokoll.Range `json:"range,omitempty"`
}

type MarkupContent struct {
	Kind MarkupKind `json:"kind"`
	Value string `json:"value"`
}

type MarkupKind string
const (
	PlainText MarkupKind = "plaintext"
	Markdown MarkupKind = "markdown"
)

type MarkedString struct {
	Language string `json:"language,omitempty"`
	Value string `json:"value"`
}
    \end{lstlisting}
    Die Implementierung des Hover-Effekts wird im Abschnitt \nameref{subsubsec:hover-service} beschrieben.\\
    Die Benutzung des Hover-Effekts wird im Abschnitt \nameref{subsubsec:useHover} (\ref{subsubsec:useHover}) beschrieben.

    \subsubsection[Faltbereich]{Faltbereich\\ {\textnormal{\footnotesize Folding Ranges (textDocument/foldingRange) \cite{folding}}}}\label{subsubsec:folding}
    Die Möglichkeit den Code in Abschnitte zu unterteilen und diese einfalten zu können, erleichtert die Übersicht in großen Dateien.
    Deshalb definiert das \acrshort{lsp} eine Funktion, um diese Bereiche an die \acrshort{ide} zu übermitteln.
    \\\\
    Während der Initialisierung kann der Client viele Vorgaben und Wünsche an den Server machen.
    Dazu zählen die gewünschte maximale Anzahl der Bereiche,
    ob nur komplette Zeilen gefaltet werden können,
    welche Falttypen unterstützt werden und ob vom Server generierte Zusammenfassungen angezeigt werden können.
    \\\\
    Die Anfrage an den Server beinhaltet nur die \acrshort{uri} der Datei.\\
    Die Antwort des Servers enthält eine Liste mit Faltbereichen.
    Die Faltbereiche decken die komplette Datei ab.
    Jeder Faltbereich enthält zusätzlich zur Startposition und Endposition auch den Falttypen und optional auch eine Zusammenfassung.
    \begin{lstlisting}[language=Go, caption=Definition eines Faltbereichs, label=lst:faltbereich]
type FoldingRange struct {
	StartLine uint32 `json:"startLine"`
	StartCharacter *uint32 `json:"startCharacter,omitempty"`
	EndLine uint32 `json:"endLine"`
	EndCharacter *uint32 `json:"endCharacter,omitempty"`
	Kind *FoldingRangeKind `json:"kind,omitempty"`
	CollapsedText *string `json:"collapsedText,omitempty"`
}

type FoldingRangeKind string
const (
	Comment FoldingRangeKind = "comment"
	Imports FoldingRangeKind = "imports"
	Region FoldingRangeKind = "region"
)
    \end{lstlisting}
    \\\\
    Die Implementierung der Faltbereiche wird im Abschnitt \nameref{subsubsec:folding} beschrieben.\\
    Die Benutzung der Faltbereiche wird im Abschnitt \nameref{subsubsec:useFaltbereiche} (\ref{subsubsec:useFaltbereiche}) beschrieben.

    \subsubsection[Auswahlbereich]{Auswahlbereich\\ {\textnormal{\footnotesize Selection Range (textDocument/selectionRange) \cite{selection}}}}\label{subsubsec:selection}
    Durch die unterschiedlichen Grammatiken aller Programmiersprachen ist eine Verallgemeinerung der Auswahlbereiche in einem Dokument unmöglich.
    Deshalb bietet das \acrshort{lsp} die Möglichkeit diese Bereiche vom Server abzufragen.
    \\\\
    Die Anfrage beinhaltet ein Dokument und verschiedene Positionen, zu denen die Auswahlbereiche erfragt werden.
    Der Vorteil von mehreren Positionen ist die Bündlung der Anfragen für Editoren mit mehreren Eingabemarken(Cursor).
    \begin{lstlisting}[language=Go, title=Auszug aus den Parametern, label=lst:selectionParams]
type SelectionRangeParams struct {
	TextDocument protokoll.TextDocumentIdentifier `json:"textDocument"`
	Positions []protokoll.Position `json:"positions"`
}
    \end{lstlisting}
    Auswahlbereiche bilden einen Auszug aus dem \acrshort{ast}.
    Um eine Auswahl zu vergrößern oder zu verkleinern wird der höhere bzw.\ tiefere Auswahlbereich aus der Hierarchie des \acrshort{ast}s benötigt.
    Deshalb beinhaltet die Antwort im \acrshort{lsp} auch die Möglichkeit pro Position eine Kette an Auswahlbereichen zu liefern.
    Diese Kette wird durch das Parent-Attribut gebildet.
    \begin{lstlisting}[language=Go, title=Antwort des Servers, label=lst:selectionResult]
type SelectionRange struct {
	Range protokoll.Range `json:"range"`
	Parent *SelectionRange `json:"parent,omitempty"`
}
type SelectionRangeResult []SelectionRange
    \end{lstlisting}
    Die Implementierung der Auswahlbereiche wird im Abschnitt \nameref{subsubsec:selection-service} beschrieben.\\
    Die Benutzung der Auswahlbereiche wird im Abschnitt \nameref{subsubsec:useAuswahlbereiche} (\ref{subsubsec:useAuswahlbereiche}) beschrieben.

    \subsubsection[Semantische Tokens]{Semantische Tokens\\ {\textnormal{\footnotesize Semantic Tokens (textDocument/semanticTokens/full) \cite{semantic}}}}\label{subsubsec:semantic}
    Um ein schnelles Verständnis einer Datei zu ermöglichen, ist die Einfärbung der Syntax und Semantik wichtig.
    Dafür stellt das \acrshort{lsp} die Möglichkeit bereit, semantische Tokens/Symbole zu übermitteln.\\
    Ein Token bezieht sich immer auf einen Bereich im Sourcecode und übermittelt einen Tokentyp und eine Auswahl der Tokenmodifikatoren.
    Die Tokentypen und Tokenmodifikatoren werden während der Initialisierung übermittelt.
    \\\\
    Ein Client kann Anfragen für die semantischen Token an den Server stellen.
    Für das DMF wurde nur die Methode `textDocument/semanticTokens/full' welche alle semantischen Token für eine Datei generiert beachtet.
    \paragraph{Die Codierung der semantischen Token}\label{par:semantic-code}\mbox{}\\
    Wenn die neuen semantischen Tokens übermittelt werden, werden die Tokens mithilfe einer Zahlenfolge codiert.
    Dies führt zu einer starken Komprimierung des Ergebnisses, welche besonders relevant für diese Methode des \acrshort{lsp}s ist, da das Ergebnis hohe Datenmengen beinhaltet.\\
    Die Einträge der Zahlenfolge werden nach dem folgenden Schema codiert:
    \begin{center}
        \begin{tabular}{| c | c | m{21.5em} |}
            \hline
            \makecell{Index in der\\ Zahlenfolge\\für Token mit \\Index i} & Name & Erklärung \\
            \hline
            5*i & deltaLine & Die Zeilen zwischen dem letzten Token und diesem Token. \\
            \hline
            5*i+1 & deltaStart & Die Zeichen zwischen dem letzten Token und diesem Token.
            Relativ zu 0, falls der aktuelle Token in einer neuen Zeile ist. \\
            \hline
            5*i+2 & length & Die Länge des Tokens. \\
            \hline
            5*i+3 & tokenType & Index des Typs des Tokens in der Semantik Token Typ Legende. \\
            \hline
            5*i+4 & tokenModifiers & Zahl deren Bits als Wahrheitswerte für jeden Modifikator aus der Legende der Semantik Token Modifikatoren.
            Der erste Bit (0b00000001) steht dabei für den ersten Modifikator. \\
            \hline
        \end{tabular}
    \end{center}
    Die Implementierung der semantischen Tokens wird im Abschnitt \hyperref[subsubsec:semantic-service]{SemanticTokensService} beschrieben.\\
    Die Benutzung der semantischen Tokens wird im Abschnitt \nameref{subsubsec:useSemanticTokens} (\ref{subsubsec:useSemanticTokens}) beschrieben.

    \subsubsection[Diagnosen]{Diagnosen\\ {\textnormal{\footnotesize Publish Diagnostics (textDocument/publishDiagnostics) \cite{diagnostics}}}}\label{subsubsec:diagnostics}
    Um Fehler, Warnungen, Informationen und Hinweise den Entwickler*innen anzeigen zu können bietet das \acrshort{lsp} die Möglichkeit Diagnosen zu übermitteln.
    Hierbei ist die Besonderheit, dass nur der Server weiß, ob und wann die Diagnosen einer Datei sich verändern.
    Deshalb bietet das \acrshort{lsp} die Möglichkeit, dass der Server Benachrichtigungen an den Client mit den Diagnosen sendet.
    \\\\
    Während der Initialisierung kann der Client (neben der Unterstützung von Feinheiten der Spezifikation) angeben, ob er Diagnosen-Tags (eng.\ diagnostic tag) unterstützt.
    Diese Tags differenzieren die Diagnosen, wie die semantischen Modifikatoren, die semantisch Tokens weiter differenzieren.
    \\\\
    Die Benachrichtigungen beinhalten eine Liste mit Diagnosen.
    Jede Diagnose bezieht sich auf einen Bereich im Sourcecode.
    Eine Diagnose kann ein Fehler, eine Warnung, eine Information oder ein Hinweis sein.\\
    Der Unterschied zwischen einer Information und einem Hinweis liegt in der Bedeutsamkeit der enthaltenen Information.
    Eine Diagnose mit einer Information sollte beim Ermitteln eines Fehlers vor den Hinweisen beachtet werden.\\
    Der Inhalt einer Diagnose setzt sich aus den Feldern `Message' und `Source' zusammen.
    `Message' beschreibt den Fehler und `Source' den Grund.\\
    Es können auch zusätzliche Informationen in einer Diagnose enthalten sein.
    Diese könne andere Stellen im Code erwähnen, die für die Diagnose bedeutend sind.
    \begin{lstlisting}[language=Go, caption=Definition des Inhalts der Benachrichtigung, label=lst:diagnostics-result]
type Diagnostic struct {
	Range Range `json:"range"`
	Severity *DiagnosticSeverity `json:"severity,omitempty"`
  	Source string `json:"source,omitempty"`
	Message string `json:"message"`
	Tags []DiagnosticTag `json:"tags,omitempty"`
	RelatedInformation []DiagnosticRelatedInformation `json:"relatedInformation,omitempty"`
}
type DiagnosticRelatedInformation struct {
	Location Location `json:"location"`
	Message string `json:"message"`
}
    \end{lstlisting}
    Die Implementierung für die Erstellung der Diagnosen wird im Abschnitt \nameref{subsubsec:diagnostics-service} beschrieben.\\
    Die Benutzung der Diagnosen wird im Abschnitt \nameref{subsubsec:useDiagnosen} (\ref{subsubsec:useDiagnosen}) beschrieben.
    \subsection{Server Implementierung}\label{subsec:server-implementierung}
    % Wie funktioniert JSON-RPC
    % Wie parsed Golang json
    % Wie werden Service Aufgerufen
    Die Serverschicht abstrahiert die Verbindung zum Client und das JSON-RPC Protkoll.
    So bekommen die Services, welche die vorher beschriebenen Funktionen implementieren, direkt Nachrichten und können auch Nachrichten verschicken.
    \subsubsection{Abstraktion der Server-Client-Verbindung}
    Da das \acrshort{lsp} Mediumunabhängig ist, muss der Server eine Abstraktion für die Verbindung bereitstellen.
    \begin{lstlisting}[language=Go]
package connect
type Connection interface {
	WriteMessage(message protokoll.Message)
	WaitForMessage() (protokoll.Message, error)
	BlockResponse(id json.RawMessage)
	Close() error
}
    \end{lstlisting}
    Das Interface Connection stellt diese Abstraktion bereit.
    Es wird für jeden Verbindungstyp implementiert.\\
    Zwischen den Verbindungstypen unterscheiden sich nur die Implementierungen der Interfaces der Standardbibliothek.\\
    Die Verbindung durchläuft immer die gleichen Schritte, nur die Richtung unterscheidet sich bei Lesen und Schreiben.
    \begin{center}
        \begin{center}
            \left\downarrow
            \left\uparrow
            \rotatebox[origin=c]{90}{\ }
            \left\vspace{1cm}
            \begin{tabular}{|c|}
                \hline
                \textit{Server}\\
                \hline
                JSON\\
                \hline
                Basis Protokoll\\
                \hline
                Medium\\
                \hline
                \textit{Client}\\
                \hline
            \end{tabular}
        \end{center}
    \end{center}
    \paragraph{JSON}\mbox{}\\
    Damit die Nachrichten übermittelt werden können, müssen sie in JSON Text geparsed werden.
    Dafür wird die Standardbibliothek von Golang genutzt.
    \begin{lstlisting}[language=Go, caption=Umwandlung von und zu JSON, label=lst:json]
message := protokoll.Message{}
// Golang -> JSON
data, err := json.Marshal(message)
// JSON -> Golang
err = json.Unmarshal(data, &message)
    \end{lstlisting}
    Das Verhalten der verschiedenen Datenstrukturen beim Parsen wird direkt bei der Definition angegeben.
    Deswegen muss keine zusätzliche Logik für einzelne Werte implementiert werden.
    Dies betrifft leere Werte, welche nicht übertragen werden sollen, und Werte, welche einen anderen Namen im JSON-Text besitzen.

    \paragraph{Basisprotokoll}\mbox{}\\
    Das \acrshort{lsp} besitzt nicht nur Spezifikationen für den Inhalt der Nachrichten, sondern auch für deren Übertragung.
    Vorausgesetzt wird nur eine bidirektionale Verbindung, welche parallel Text übertragen kann.\\
    Jede Nachricht im Basisprotokoll besteht aus zwei Teilen: dem Header und dem Inhalt.
    \\\\
    Der Header enthält Angabe zum Einlesen.
    Diese werden jeweils in eine eigene Zeile geschrieben.
    Die Zeilen werden mit den Kontrollzeichen `{\textbackslash}r{\textbackslash}n' beendet.
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Variable & Beschreibung \\
            \hline
            \hline
            Content-Length & Die Länge der übertragenen Nachricht (in Bytes).\\
            \hline
            Content-Type & \makecell{Der \acrshort{mime}-Typ der Nachricht.\\
            Wenn nicht angegeben: `application/vscode-jsonrpc; charset=utf-8'}\\
            \hline
        \end{tabular}
        \\
        \cite{header}
    \end{center}
    Der Header wird durch eine inhaltsleere Zeile beendet.
    Diese enthält dennoch die Kontrollzeichensequenz `{\textbackslash}r{\textbackslash}n'.\\
    Zuletzt folgt der Inhalt der Nachricht.
    Dabei ist wichtig, dass die angegebene Länge genau der Länge der Nachricht entspricht.
    \\\\
    Um das Basisprotokoll lesen zu können, wird der `BufReader' der Golang-Standardbibliothek verwendet.
    Beim Lesen aus dem `BufReader' kann ein Zeichen, bis zu dem gelesen werden soll, angegeben werden.
    So kann die Verbindung zeilenweise ausgelesen werden.\\
    Beginnt eine Zeile mit dem Identifier der Länge der Datei, so wird der Rest der Zeile als Zahl interpretiert und zwischengespeichert.\\
    Wird eine leere Zeile gelesen wird die Schleife zum Auslesen des Headers beendet.\\
    Nun wird ein Buffer mit der gespeicherten Größe angelegt und mit dem Inhalt aus der Verbindung befüllt.
    Der Inhalt des Buffers kann nun als Text weiter verwendet werden.
    \\\\
    Das Schreiben im Basisprotokoll beginnt mit der Messung der Nachrichtenlänge.
    Nun kann der Header in die Verbindung geschrieben werden.
    Schlussendlich wird der Inhalt in die Verbindung geschrieben.\\
    Diese Schreibvorgänge müssen synchron erfolgen.
    Deshalb enthält jede Verbindung einen ``actionChannel'', über den Funktionen an eine Routine übermittelt werden.
    Innerhalb der Routine werden die Funktionen synchron ausgeführt.\\
    Dieses Pattern wird auch im \nameref{subsubsec:file-service} verwendet und anhand eines Beispieles genauer erläutert.

    \paragraph{Medium}\mbox{}\\
    Der \acrshort{dmf}-\acrshort{lsp}-Server unterstützt zwei Medien: Standard-IO und \acrshort{tcp}-Sockets.\\
    Standard-IO bietet sich für die meisten Fälle an, da der Prozess häufig von der \acrshort{ide} verwaltet wird.
    Diese Übertragung enthält auch keine weiteren Schichten und ist somit sehr schnell.
    Sie vereinfacht auch den Serverprozess, da es nur einen Client geben kann.
    \begin{lstlisting}[language=Go, caption=Start eines Standard-IO-Servers, label=lst:stdServer]
newServer := server.NewServer(connect.NewStdIOConnection())
newServer.MessageLoop()
    \end{lstlisting}
    Wenn der Prozess nicht von der \acrshort{ide} verwaltet werden kann und der Server zentral gehostet werden soll, können \acrshort{tcp}-Sockets genutzt werden.
    Sie ermöglichen mehreren Nutzer*innen eine Serverinstanz zu nutzen und die Nutzung eines Servers, welcher nicht auf dem gleichen Computer läuft.\\
    Bei der Implementierung ist die Unterscheidung zwischen dem Begriff Server und der Datenstruktur `Server' zu beachten.
    Für jede Verbindung wird eine eigene Server-Instanz in einer eigenen Routine erzeugt.
    \begin{lstlisting}[language=Go, caption=Verwaltung des \acrshort{tcp}-Servers, label=lst:tcpServer]
listener, err := net.Listen("tcp", args.Port)
for {
    conn, err := listener.Accept()

    // Server starten
    go func(conn net.Conn) {
        newServer := server.NewServer(
                        connect.NewSocketConnection(conn))
        newServer.MessageLoop()
    }(conn)
}
    \end{lstlisting}

    \subsubsection{Abstraktion des JSON-RPC-Protokolls}
    Die Abstraktion des JSON-RPC-Protokolls verbindet die Services und die Verbindung zum Client.
    Sie beinhaltet zwei Phasen: Initialisierung und Verarbeitung.\\
    Die Initialisierung erstellt alle Services und trägt diese in eine Map ein.
    Die Map enthält die Referenzen zwischen den Methodennamen und den Services.
    Die Methodennamen liefern die Services, so kann ein Service mit nur zwei Zeilen hinzugefügt werden:
    \begin{lstlisting}{language=Go, caption=Registierung eines Services, label:registerService}
newCancelService := cancelService.NewCancelService(con)
s.addHandler(newCancelService)
    \end{lstlisting}
    Die Verarbeitung beginnt mit Lesen der `initialize'-Methode.
    Diese wird an die Services weitergereicht, welche währenddessen die Antwort befüllen.\\
    Nachdem die Kommunikation initialisiert wurde, beginnt der Nachrichtenkreislauf.
    \begin{lstlisting}[language=Go, caption=Nachrichtenkreislauf, label=lst:messageLopp]
MessageLoop:
	for {
		if s.nextMethod(logger) {
			break MessageLoop
		}
	}
    \end{lstlisting}
    Zuerst wird der blockierende Aufruf der Kommunikation durchgeführt. \\
    Die Verarbeitung wird mit Zuordnung der Methode fortgeführt.
    Vor den Services muss auf die `shutdown'-Methode überprüft werden.
    Die Verarbeitung der \acrshort{lsp}-Lifecycle-Nachrichten fällt in den Aufgabenbereich des Servers.
    Sollte die `shutdown'-Anfrage vorliegen, wird der Message-Loop beendet.
    Somit wird schließlich der Server heruntergefahren.
    \\\\
    Für alle anderen Methoden wird die Map der Services genutzt, um den richtigen Service zu finden.
    Die Verarbeitung wird im Service fortgeführt.
    Dafür wird eine neue Routine gestartet, so kann der Server schon während der Verarbeitung die nächste Nachricht einlesen.
    \begin{lstlisting}[language=Go, caption=Verarbeitung einer Nachricht, label=lst:handleMethod]
package server
func (s *Server) nextMethod(logger *log.Logger) bool {
	message, err := s.con.WaitForMessage()

	if err != nil {
		logger.Printf("%sError While Reading Message: %e\n", logService.ERROR, err)
		return false
	} else {
		// Lifecycle Methods
		switch message.Method {
		case "shutdown":
			logger.Printf("%sReceived Shutdown Request\n", logService.INFO)
			s.con.WriteMessage(protokoll.Message{
				JsonRPC: "2.0",
				ID:      message.ID,
				Method:  "",
				Params:  nil,
				Result:  nil,
				Error:   nil,
			})
			return true
		}
		handler, found := s.methodMap[message.Method]
		if !found {
			logger.Printf("%sMethod not Found: %v\n", logService.ERROR, message)
			connectUtils.WriteErrorToCon(s.con, message.ID, errors.New("method not found"), protokoll.MethodNotFound)
		} else {
			logger.Printf("%sHandle Method: %s \n", logService.INFO, message.Method)
			go handler.HandleMethod(message)
		}
	}
	return false
}
    \end{lstlisting}
    \subsection{Die \acrshort{lsp}-Services}
    Die Schnittstelle für alle Services zu der Server-Schicht bildet das MethodHandler-Interface:
    \begin{lstlisting}[language=Go]
package service
type MethodHandler interface {
	Initialize(params *initialize.InitializeParams,
                result *initialize.InitializeResult)
	GetMethods() []string
	HandleMethod(message protokoll.Message)
}
    \end{lstlisting}
    Jeder Service implementiert die drei Methoden.
    \begin{enumerate}
        \item \textbf{Initialize} \\
        Der Service liest die Fähigkeiten des Clients und konfiguriert sich selbständig.
        Sollte der Client den Service nicht unterstützen, muss er sich deaktivieren.
        Der Service schreibt seine Fähigkeiten in die Antwort des Servers.
        \item \textbf{GetMethods} \\
        Gibt die Methoden aus dem \acrshort{lsp} zurück für die der Service Meldungen verarbeitet.
        \item \textbf{HandleMethod} \\
        Verarbeitet die Nachricht.
    \end{enumerate}


    \subsubsection[FileService]{FileService \secsubtitle{\nameref{subsubsec:dokumenten-synchronisation}}}
    \label{subsubsec:file-service}
    Der FileService ist die Schnittstelle zwischen den Dateien, den Parsern und den restlichen Services.
    Wenn ein anderer Service auf Dateien, das semantische Modell oder den Lookup zugreifen möchte, werden Methoden des FileServices genutzt.
    \begin{lstlisting}[language=Go]
package fileService
type FileService struct {
	mapActionChannel chan func()
	handleMap map[string]*fileHandle
	listeners []FileChangeListener
	con       connect.Connection
}
    \end{lstlisting}
    In der ``handleMap'' werden ``fileHandles'' gespeichert.
    Ein FileHandle speichert alle Daten zu einer Datei und wird mit jeder Veränderung aktualisiert.
    \begin{lstlisting}[language=Go]
package fileService
type fileHandle struct {
	FileContent string
	Ast         *tree_sitter.Tree
	Model       *smodel.Model
	LookUp      *smodel.TypeLookUp
	Version     int32
}
    \end{lstlisting}
    Um einen FileHandle zu erzeugen, wird der Inhalt der Datei mithilfe Semantik-Schicht geparst.\\
    Wird der Dateiinhalt geändert, so werden die Änderungen an die Semantik-Schicht übergeben.
    Dort werden die Änderungen zum inkrementellen Parsen des neuen Dateiinhalts genutzt.
    Abschließend wird der Lookup erzeugt und die semantischen Regeln durchlaufen.
    \\\\
    Aufgrund der parallelen Verarbeitung der Nachriten im \acrshort{dmf}-\acrshort{lsp}-Server, kann es parallel zur Aktualisierung eines FileHandles zu einem Zugriff auf den FileHandle kommen.
    Damit alle Aktionen synchronisiert werden besitzt der FileService den ``mapActionChannel''.
    Bei der Erzeugung des Channels wird eine Routine gestartet, welche die Funktionen aus dem Channel liest und synchron aufruft.
    \begin{lstlisting}[language=Go, caption=Erzeugung des ActionChannels, label=lst:createActionChannel]
func createActionChannel() chan func() {
	c := make(chan func(), 5)
	go func() {
		for f := range c {
			f()
		}
	}()
	return c
}
    \end{lstlisting}
    Jeder Zugriff auf die ``handleMap'' muss in einer Funktion geschehen, welche von der Routine des Channels ausgeführt wird.
    Um auf Werte, welche innerhalb der Funktion geladen werden, auch außerhalb der Funktion zuzugreifen, wird ein zusätzlicher Channel erzeugt, über den die Werte übertragen werden.\\
    Dieses Pattern wird z.B. beim Laden des Dateiinhalts durch andere Services genutzt.
    \begin{lstlisting}[language=Go, captio=Laden eines FileHandles]
func (receiver *FileService) GetFileContent(uri protokoll.DocumentURI) (FileContent, error) {
	returnChannel := make(chan struct {
		FileContent
		error
	})
	defer close(returnChannel)
	receiver.mapActionChannel <- func() {
		handle, found := receiver.handleMap[string(uri)]

		if found {
			returnChannel <- struct {
				FileContent
				error
			}{FileContent: handle.ToContent(), error: nil}
		} else {
			logger.Printf("%sFileHandle for file(%v) doesn't exists!\n", logService.ERROR, uri)
			returnChannel <- struct {
				FileContent
				error
			}{FileContent: FileContent{}, error: errors.New("file is unknown")}
		}
	}
	ret := <-returnChannel
	return ret.FileContent, ret.error
}
    \end{lstlisting}

    \paragraph{FileChangeListener}
    Es gibt Funktionen im \acrshort{lsp} die nicht durch eingehende Nachrichten ausgelöst werden, sondern nach Dateiänderungen automatisch an den Client übermittelt werden.
    Dafür gibt es im \acrshort{dmf}-\acrshort{lsp}-Server die FileChangeListener.
    \begin{lstlisting}[language=Go]
package fileService
type FileChangeListener interface {
	HandleFileChange(file protokoll.DocumentURI, fileContent string,
                    ast *tree_sitter.Tree, model *smodel.Model,
                    lookup smodel.TypeLookUp,
                    errorElements []errElement.ErrorElement,
                    version int32)
}
    \end{lstlisting}
    Der FileService enthält Referenzen zu allen aktiven Listenern.
    Nachdem ein FileHandle erstellt oder bearbeitet wurde, werden alle Listener durchlaufen.\\
    Im \acrshort{dmf}-\acrshort{lsp}-Server ist nur ein FileChangeListener implementiert:
    \subparagraph[DiagnosticsService]{Der DiagnosticsService }\label{subsubsec:diagnostics-service}
    (Protokoll im Abschnitt \ref{subsubsec:diagnostics})
    übermittelt die aktuellen Fehler in der Modelldatei an den Client.
    Dafür werden alle ErrorElemente in die Diagnostic Strukturen des \acrshort{lsp}s übersetzt.
    Schließlich werden die Daten mithilfe einer Request-Nachricht für die Methode ``textDocument/publishDiagnostics'' an den Client übermittelt.

    \subsubsection{SemanticTokensService \secsubtitle{\nameref{subsubsec:semantic}}}\label{subsubsec:semantic-service}
    Der SematicTokensService implementiert die Methode für die semantischen Tokens.
    Diese Tokens werden für die Einfärbung des Textes einer Datei nach der Syntax und Semantik genutzt.
    Mit dieser Einfärbung des Sourcecodes können Entwickler*innen schnell ein Verständnis über die Datei entwickeln.
    \\\\
    Ein Token bezieht sich immer auf einen Bereich im Sourcecode und übermittelt einen Tokentyp und eine Auswahl der Tokenmodifikatoren.
    Die Tokentypen und Tokenmodifikatoren werden während der Initialisierung übermittelt.
    Dabei ist für die Codierung (siehe \nameref{par:semantic-code}) der Index in den Listen entscheidend. \\
    Für das \acrshort{dmf} wird nur die folgende Auswahl der Tokenmodifikatoren genutzt.
    \begin{center}
        \begin{tabular}{|c|c|}
            1 & declaration \\
            \hline
            2 & definition
        \end{tabular}
    \end{center}

    \paragraph{Die Tokentypen und ihre Verwendung zusammen mit den Tokenmodifikatoren}
    \begin{center}


        \begin{tabular}{|c|c|>{\centering\arraybackslash}m{\mycolwidth}|}
            \hline
            Index & Token Typ & \makecell{Verwendung im DMF \\
                \begin{tabular}{c|c}
                    Tokenmodifikator(-en) & Verwendung
                \end{tabular}}\tabularnewline
            \hline
            0 & namespace & \tablecell{declaration & Für den Namen eines Packages.}\tabularnewline
            \hline
            1 & type & \tablecell{- &
            \makecell[l]{Für das AST-Element ``reftype''.\\Für den Override Wert des Java Typens.}
            }\tabularnewline
            \hline
            2 & class & \tablecell{- & Für den Override Wert der Java Klasse, der Oberklasse und der implementierten Interfaces.}\tabularnewline[-1ex]
            \hline
            3 & enum & \tablecell{ declaration &  Für den Namen eines Enums.}\tabularnewline
            \hline
            4 & interface & \tablecell{ declaration & Für den Namen eines Interfaces.}\tabularnewline
            \hline
            5 & struct & \tablecell{ declaration & Für den Namen eines Structs oder einer Entity.}\tabularnewline
            \hline
            6 & parameter & \tablecell{ declaration & Für die Parameter einer Funktion. }\tabularnewline
            \hline
            7 & variable &
            \tablecell{
                - & Für die Namen der Variablen im Entity Identifier. Für den Override Wert des Java Namens.\\
                \hline
                declaration & Für die Namen von Argumenten, Referenzen und MultiReferenzen.\\
            }\\[-1ex]
            \hline
            8 & property & Platzhalter\tabularnewline
            \hline
            9 & number & \tablecell{ definition & Für alle Zahlenwerte in einer Enum-Konstante.}\tabularnewline
            \hline
            10 & enumMember & \tablecell{declaration& Für den Namen einer Enum-Konstante. }\tabularnewline
            \hline
            11 & function & \tablecell{ declaration & Für den Namen einer Funktion. }\tabularnewline
            \hline
            12 & comment & \tablecell{ - & Für alle Kommentare.}\tabularnewline
            \hline
            13 & keyword & \tablecell{ - & Für alle Keywords.}\tabularnewline
            \hline
            14 & string & \tablecell{ - & Für alle Strings außer den Werten im Override. }\tabularnewline
            \hline
            15 & modifier & Platzhalter\tabularnewline
            \hline
            16 & decorator & \tablecell{ - & Für den Override Wert der Java Annotations. }\tabularnewline
            \hline
        \end{tabular}
    \end{center}

    \paragraph{Generierung der Semantik Tokens}\mbox{}\\
    Die Semantik Tokens werden mithilfe zweier Algorithmen generiert.
    \subparagraph{Mithilfe des \acrshort{ast}s} werden alle \acrshort{ast}-Elemente durchlaufen.
    Werden Elemente erreicht, deren semantischer Token allein am \acrshort{ast} Element bestimmt werden kann, so werden die Token generiert.
    Dazu gehören die meisten semantischen Token.
    \subparagraph{Mithilfe des semantischen Modells} werden die restlichen Token bestimmt.
    Dies ist möglich da die Elemente im semantischen Modell Referenzen zum \acrshort{ast} beinhalten.
    Dazu gehören die Namen der verschiedenen Inhalte, wie z.B.\ von Argumenten.
    Bei diesen Namen wird das gleiche \acrshort{ast}-Element genutzt, wodurch sie nur durch das semantische Parsen unterscheidbar sind.
    \\\\
    Die semantischen Tokens befinden sich nun in einer Liste mit semantischen Elementen.
    Diese müssen für die Antwort codiert werden.
    \begin{lstlisting}[language=Go, caption=semantisches Element, label=lst:semantic-element]
type semanticElement struct {
	line           uint32
	start          uint32
	length         uint32
	tokenType      uint32
	tokenModifiers uint32
}
    \end{lstlisting}

    \subparagraph{Die Codierung der semantischen Tokens} muss zunächst die generierten Tokens sortieren, da keine Garantie für die richtige Reihenfolge durch die beiden Algorithmen existiert.
    \begin{lstlisting}[language=Go,label={lst:sortSemanticTokens}]
slices.SortFunc(semanticElements, func(a, b *semanticElement) int {
    if a.line == b.line {
        return cmp.Compare(a.start, b.start)
    }
    return cmp.Compare(a.line, b.line)
})
    \end{lstlisting}
    Nach der Sortierung können die Tokens durchlaufen werden.
    \begin{lstlisting}[language=Go]
data := make([]uint32, len(semanticElements)*5)

lastLine := uint32(0)
lastStart := uint32(0)

for i, element := range semanticElements {
    line := element.line
    start := element.start
    length := element.length
    tokenType := element.tokenType
    tokenModifiers := element.tokenModifiers
    if line < lastLine {
        continue
    }

    if line == lastLine && start < lastStart {
        continue
    }

    // Calculate delta encoding
    deltaLine := line - lastLine
    deltaStart := uint32(0)
    if line == lastLine {
        deltaStart = start - lastStart
    } else {
        deltaStart = start
    }

    data[i*5] = deltaLine
    data[i*5+1] = deltaStart
    data[i*5+2] = length
    data[i*5+3] = tokenType
    data[i*5+4] = tokenModifiers

    lastLine = line
    lastStart = start
}
    \end{lstlisting}
    Beim Durchlaufen wird ein Integer-Slice erstellt. \\
    Für jeden Token werden die 5 Zahlen nach dem Protokoll hinzugefügt. \\
    Überschneiden sich Token oder sind nicht in der richtigen Reihenfolge werden die Token ignoriert. \\
    Die aktuelle Zeile und Spalte im Text wird nach jedem Token aktualisiert.

    \subsubsection[SelectionRangeService]{SelectionRangeService \secsubtitle{\nameref{subsubsec:selection}}}\label{subsubsec:selection-service}
    Der SelectionRangeService implementiert die \acrshort{lsp}-Methode ``textDocument/selectionRange''.
    Diese wird dafür genutzt, dass bei der Auswahl immer der richtige Text ausgewählt wird. \\
    Die Bereiche werden im Service mithilfe des \acrshort{ast}s berechnet.
    \begin{lstlisting}[language=Go]
package selectionRangeService
func (s *SelectionRangeService) computeSelectionRangeForPosition(
        content fileService.FileContent,
        position protokoll.Position) *selectionRange.SelectionRange {
	finder := util.NewNodeFinder([]byte(content.Content))
	node := finder.FindSmallestNodeAroundPosition(content.Ast, position)
	var currentRange *selectionRange.SelectionRange
	for node != nil {
		newRange := &selectionRange.SelectionRange{
			Range: protokoll.ToRange(node.Range()),
		}
		newRange.Parent = currentRange
		currentRange = newRange

		node = node.Parent()
	}
	return currentRange
}
    \end{lstlisting}
    Es wird zunächst das kleinste Element (das ``Blatt'' des Baums) des \acrshort{ast}s für die Position bestimmt.\\
    Nun wird durch die Schichten des \acrshort{ast}s bis zur Wurzel iteriert.
    Es wird bei jedem Element eine neue ``SelectionRange'' Instanz angelegt.
    Diese ``SelectionRange'' enthält immer den Bereich und eine Referenz zu der vorherigen ``SelectionRange''.
    Durch die Referenz wird die Baum-Struktur auch im Ergebnis übermittelt und es müssen weniger Anfragen an den Server gesendet werden.\\

    Ein Request kann mehrere Positionen enthalten.
    Deshalb wird der Algorithmus für jede Position ausgeführt.

    \subsubsection[FoldingService]{FoldingService \secsubtitle{\nameref{subsubsec:folding}}}\label{subsubsec:folding-service}
    Der FoldingService stellt die Methode `textDocument/foldingRange', für die Übermittlung der faltbaren Bereiche, bereit.
    Es werden drei verschiende Bereicharten berechnet: PackageElemente, Kommentare und der Import-Block.
    \subparagraph{Für die PackageElemente} werden die \acrshort{ast}-Nodes des Elements durchlaufen.
    Es wird immer der Bereich, welcher von den geschweiften Klammern umschlossen wird, gefaltet.
    Deshalb werden die auch diese Nodes beim Durchlaufen gesucht.
    \begin{lstlisting}[language=Go, caption=Suche nach Start- und Ende-Node des Faltbereichs eines PackageElements, label=lst:foldPackageElement]
cursor.GotoFirstChild()
for {
    if cursor.Node().GrammarName() == "{" {
        startNode = cursor.Node()
    }
    if cursor.Node().GrammarName() == "}" {
        endNode = cursor.Node()
    }
    if !cursor.GotoNextSibling() {
        break
    }
}
    \end{lstlisting}
    Mithilfe diese Nodes kann auf die Zeilen und Spalten beider Positonen zugegriffen werden.
    Damit die Klammern auch noch in der \acrshort{ide} angezeigt werden, wird der Startzeichenindex (Start-Spalte) um 1 erhöht und der Endzeichenindex (End-Spalte) um 1 gesenkt.

    \subparagraph{Für die Kommentare} wird die Query-Funktion von Treesitter genutzt.
    \begin{lstlisting}[capture=Die Query für alle Kommentare, label=lst:commentQuery]
(comment_block) @cb
    \end{lstlisting}
    Die Ergebnisse einer Query werden in der Treesitter-\acrshort{api} QueryMatches genannt.
    Für diese Query enthalten sie alle `comment_block' Nodes im \acrshort{ast}.
    Durch die Ergebnisse wird iteriert und für jeden QueryMatch ein Faltbereich erstellt.
    Dabei wird zwischen einzeiligen und mehrzeiligen Kommentaren unterschieden, da die Positionen unterschiedlich interpretiert werden müssen.
    Einzeilige Kommentare werden nicht in jeder \acrshort{ide} gut verarbeitet, deshalb können sie über die Argumente beim Start des \acrshort{lsp}-Servers ausgeschaltet werden.
    \begin{lstlisting}[language=Go, caption=Auszug aus der Bestimmung der Faltbereiche für die Kommentare, label=lst:foldingCommentsFor]
queryCursor := tree_sitter.NewQueryCursor()
captures := queryCursor.Captures(f.kommentarQuery,
                            root.RootNode(), nil)
for match, index := captures.Next(); match != nil;
        match, index = captures.Next() {
    node := match.Captures[index].Node
    startPos := node.StartPosition()
    endPos := node.EndPosition()

    if startPos.Row != endPos.Row {
        // Mehrzeilige Kommentare
    }else if !args.DisableSingleLineCommentsFolding{
        // Einzeilige Kommentare
    }
}
    \end{lstlisting}
    \textbf{Bei allen Kommentaren} liegt das Ende im Ergebnis der Query in der nächsten Zeile.
    Der Faltbereich soll jedoch am Ende der Kommentarzeile enden.
    Deshalb wird die Endposition verschoben.\\
    \textbf{Bei mehrzeiligen Kommentaren} müssen Startzeichenindex und Endzeichenindex anhand von unterschiedlichen Zeilen bestimmt werden.
    Dafür muss der Inhalt des Kommentars in Zeilen aufgeteilt werden.
    Die erste und letzte Zeile werden für die Indexe genutzt.
    Für die Zusammenfassung wird der Inhalt des Kommentars in der ersten Zeile genutzt.\\
    \textbf{Bei einzeiligen Kommentaren} können die Indexe anhand der einen Zeile bestimmt werden.

    \subparagraph{Für den Import-Block} wird die Node des Import-Blocks aus dem \acrshort{ast} genutzt.
    Diese enthält jedoch alle Zeilen, ab dem ersten Import-Statement bis zum ersten PackageElement.
    Deshalb werden die Leerzeilen am Ende des Import-Blocks herausgefiltert.
    \begin{lstlisting}[language=Go, caption=Filterung der leeren Zeilen, label=lst:filterImportFolding]
var endPos tree_sitter.Point
for {
    if cursor.Node().GrammarName() == "import_block" {
        importBlock = cursor.Node()
        cursor.GotoLastChild()
        endPos = cursor.Node().EndPosition()
        text := cursor.Node().Utf8Text([]byte(content))
        split := strings.Split(text, "\n")
        length := len(split)
        for i := range split {
            s := split[length-i-1]
            if strings.ContainsFunc(s, func(r rune) bool {
                switch r {
                case ' ', '\n':
                    return false
                default:
                    return true
                }
            }) {
                endPos.Column = uint(len(split[length-i-1]))
            } else {
                endPos.Row--
            }
        }
        break
    }
    if !cursor.GotoNextSibling() {
        break
    }
}
    \end{lstlisting}

    \subsubsection[ReferenceService]{ReferenceService \secsubtitle{\nameref{subsubsec:referenzen}}}\label{subsubsec:reference-service}
    Um zwischen den Referenzen und den Deklarationen in der \acrshort{ide} in der Datei springen zu können, implementiert der ReferenzService die Methoden `textDocument/references' und `textDocument/declaration'. \\
    Die Parameter für beide Methoden enthalten das Textdokument und die Position im Dokument.
    Um die Referenz zu finden, wird der \acrshort{ast} vom Blatt an der Position zur Wurzel durchlaufen.
    Dabei werden für folgende Node-Typen die erste Node gespeichert.
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            \acrshort{ast}-Node Namen & Verwendung \\
            \hline
            reftype & Referenzen, Multireferenzen oder Parameter \\
            \hline
            identifier & Namen von Variablen oder Funktionen\\
            \hline
            \makecell{package_block, struct_block, enum_block,\\entity_block, interface_block}& PackageElemente\\
            \hline
        \end{tabular}
    \end{center}
    Mithilfe dieser Nodes kann der Name für den LookUp der PackageElemente und der Name des NamedElements innerhalb des PackageElements bestimmt werden.

    \paragraph{Referenzen}\mbox{}\\
    Nachdem das PackageElement und der Name bestimmt wurden, wird unterschieden, ob es sich um einen Typ oder um eine Variable handelt.
    \\
    Für die \textbf{Variablen} wird das aktuelle Element und alle SubElemente (Elemente durch Abstraktion) durchsucht.
    In den Elementen wird nach der Variable über den NamedElement-LookUp und in dem EntityIdentifier gesucht.
    \\
    Für die Suche nach \textbf{Typ}-Referenzen müssen alle PackageElemente durchsucht werden.
    In den PackageElementen werden Referenzen, Multireferenzen, Parameter und die Abstraktion durchsucht.

    \paragraph{Deklarationen}\mbox{}\\
    Auch bei den Deklarationen wird zwischen Typen und Variablen unterschieden. \\
    Für die \textbf{Variablen} wird das Element und die SubElemente durchsucht.
    Jedoch werden nur die Deklarationen der Variablen nach der gesuchten Variable durchsucht.\\
    Die Suche nach \textbf{Typen} wird wie für die Variablen für die PackageElemente durchgeführt.

    \subsubsection[HoverService]{HoverService \secsubtitle{\nameref{subsubsec:hover}}}\label{subsubsec:hover-service}
    Der HoverService lässt die Entwickler*innen Zusammenfassungen für jedes Element aufrufen.
    Um zu bestimmen, welche Zusammenfasssung zu welchen Element übermittelt werden muss, wird zu Beginn jeder Hover-Anfrage die kleinsten Nodes verschiedener Typen bestimmt.
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Zusammenfassung & \acrshort{ast}-Node-Typen \\
            \hline
            Variable & arg_block, ref_block, multi_block \\
            \hline
            EntityIdentifier & identifier_statement\\
            \hline
            Konstante & enum_constant \\
            \hline
            Kommentar & comment_block \\
            \hline
            PackageElement & \makecell{package_block, struct_block, enum_block,\\entity_block, interface_block} \\
            \hline
            Import & import_statement\\
            \hline
            Model Deklaration & model_declaration \\
            \hline
            DMF Deklaration & dmf_declaration \\
            \hline
        \end{tabular}
    \end{center}

    
    \paragraph{Das Generieren der Zusammenfassungen} folgt für jede Zusammenfassung dem gleichen Ablauf.
    Zuerst werden anhand der \acrshort{ast}-Nodes die Elemente aus dem semantischen Modell bestimmt.
    Aus diesen Elementen wird eine spezifische Datenstruktur erstellt.
    Mithilfe dieser Datenstruktur kann das jeweilige Template ausgeführt werden.

    \paragraph{Nutzung von Golang-Templates}\mbox{}\\
    Die Standard Bibliothek von Golang bietet eine Template-Engine die für das Generieren von Texten genutzt wird.
    Die \acrshort{api} besteht dabei aus 3 Komponenten: Templates, Funktionen und Datenstrukturen.
    \begin{lstlisting}[language=Go, caption=Ablauf der Template-\acrshort{api}, label=lst:template]
// Inkludierung der Templates
//go:embed template/*
var tmplFiles embed.FS

// Vorbereiten der Templates
templates = template.Must(template.New("").
            Funcs(funcMap).
            ParseFS(tmplFiles, "template/*"))

// Generieren mit Templates
buffer := bytes.NewBuffer(make([]byte, 0))
err := templates.ExecuteTemplate(buffer, "variable", data)
return buffer.String()
    \end{lstlisting}
    \textbf{Die Templates} werden in eigenen Dateien abgelegt.
    Mithilfe der Golang-Embedded-\acrshort{api} werden diese Dateien in die ausführbare Datei kopiert und können während der Ausführung ausgelesen werden.\\
    Ein Template wird immer mit einer Datenstruktur aufgerufen.
    Innerhalb eines Templates werden Kontrollstrukturen und Zugriffe auf die Datenstruktur innerhalb von Statements mit `\{\{' und `\}\}' gekennzeichnet.
    Statements in Templates folgen einer simplifizierten Golang Syntax.
    Das Ergebnis nach ihrer Evaluierung wird in das Ergebnis eingefügt.
    Die größte Simplifizierung sind die Blöcke der Kontrollstrukturen.
    Die Beginnen immer mit einem Statement in der Syntax des jeweiligen Keywords und enden mit dem `\{\{end\}\}'-Statement.\\
    Ein Template wird definiert mit dem Define-Statement (`\{\{define "name"\}\}').
    Der Name im Statement wird später zum Aufrufen des Templates genutzt. \\
    Die Übergebene Datenstruktur wird immer mit `.' adressiert.
    So kann eine Variable der Datenstruktur mithilfe von `\{\{.Variablenname\}\}' eingefügt werden.
    Es ist auch möglich, lokale Variablen zu definieren, z.B. `\{\{\$importSlice := getImports .\}\}'.
    Ein Name einer lokalen Variable beginnt immer mit dem Zeichen \$.\\
    Funktionen werden ohne Klammern aufgerufen, jedoch können Klammern zur Abgrenzung der Parameter verschiedener Funktionen genutzt werden.
    Das Statement `ne (len \$importSlice) 0' wird zu einem Wahrheitswert evaluieren.
    Der Aufruf der Funktion `len' befindet sich in Klammern, sodass das Ergebnis als ein Parameter der Funktion `ne' verwendet wird.\\
    Mithilfe von `if' und `range' Statements kann der Ablauf eines Templates gesteuert werden.
    Ein `if'-Statement funktioniert als Kontrollstruktur, die einen Teil des Templates abhängig von einer Bedingung ausführt.
    Es kann mit einem `else'-Statement erweitert werden.
    Ein `range'-Statement übernimmt die Funktion der Schleifen.
    Es wird immer durch eine Slice iteriert, z.B. `\{\{range \$index, \$use := .Uses\}\}'.\\
    Es können andere Templates aufgerufen werden.
    Dabei kann nur ein Parameter(=eine Datenstruktur) übergeben werden, weshalb Methoden häufig mehrere Parameter in eine Datenstruktur kombinieren.
    Ein Aufruf-Statement enthält neben dem Parameter auch den Namen des Templates: `\{\{template "parameter" \$element\}\}'.
    \\
    \textbf{Die Funktionen} werden in Go geschrieben.
    Eine Map dient zum Aufruf der Funktionen während der Generierung.
    Zwischen Funktionen, Templates und Datenstrukturen wird während der Kompilierung und der Vorbereitung der Templates keine Typ-Überprüfung durchgeführt.
    Besitzen die Parameter während der Generierung die falschen Typen, wird die Generierung mit einem Fehler abgebrochen.\\
    Funktionen besitzen keine Referenzen zum Kontext, in dem die Generierung gestartet wurde.
    Deshalb bleiben nur noch die globalen Elemente und die Parameter.
    Globale Elemente können jedoch diesen Kontext auch nicht speichern, wenn die Generierung parallel ausgeführt wird.
    Somit wird jeder erforderlicher Kontext in den Parametern übergeben.
    \\
    \textbf{Die Datenstrukturen} werden normal im Go-Code definiert.
    Sie enthalten neben den Daten aus dem semantischen Modell auch den eventuellen Kontext für den Aufruf für eine Funktion oder bündeln Parameter für den Aufruf eines Templates.
    \\
    \textbf{Bei der Generierung} wird ein Writer, der Name des Templates und die Datenstruktur übergeben.
    Das Writer-Interface bietet eine Abstraktion, um Ziel und Implementierungsunabhängig Schreibvorgänge abbilden zu können.
    Um die Zusammenfassung später als String übergeben zu können, wird ein Buffer genutzt.
    \\\\
    Im folgenden Template für die Zusammenfassung des Entity-Identifiers werden einige der beschriebenen Funktionen der Golang Templates genutzt.
    Deutlich komplexere Templates werden vom Generator genutzt.
    Ein Auszug aus diesen Templates befindet sich im Anhang im Abschnitt \nameref{sec:dateien-aus-der-implementierung-des-dmfs}.
    \begin{lstlisting}[language=markdown, caption=Template der Zusammenfassung des Entity-Identifiers]
{{define "identifier"}}
#### Identifier von [{{.Name}}]({{.NameLink}})
{{.Kommentar}}
---
{{range $index, $element :=  .Elemente}}* **{{$element.Typ}} [{{$element.Name}}]({{$element.Link}})**
{{$element.Kommentar}}
{{end}}
{{end}}
    \end{lstlisting}
    \\\\
    Die verschiedenen Zusammenfassungen werden im Abschnitt \nameref{subsubsec:useHover} beschrieben.

    \subsubsection[CancelService]{CancelService \secsubtitle{\nameref{subsubsec:cancel}}}\label{subsubsec:cancel-service}
    Der CancelService wird zum Abbruch von nicht mehr benötigten Anfragen genutzt.
    Um eine Abstraktion über alle Services zu ermöglichen, wird der Abbruch direkt in der Abstraktion der Verbindung implementiert.
    Innerhalb der Verbindung wird gespeichert, ob eine Antwort für eine Anfrage versendet werden soll.
    Wurde die Antwort vom CancelService blockiert, so wird die Antwort ignoriert.
    Um zu identifizieren, welche Antworten blockiert wurden, wird die ID der Anfrage genutzt.
    Diese wird auch in den Parametern der Abbruch-Anfrage übergeben.


\end{document}