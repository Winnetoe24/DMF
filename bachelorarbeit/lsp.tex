\documentclass[./einleitung.tex]{subfiles}
\usepackage{mdwtab}
\usepackage{makecell}
\usepackage{mdwtab}
\normalsize

\begin{document}
    \section{Der \acrshort{lsp}-Server}\label{sec:der-lsp-server}
    Der \acrshort{lsp}-Server besteht aus 3 Bereichen:
    \begin{enumerate}
        \item Dem Modell für das \acrlong{lsp}.
        \item Der Implementierung der Server-Schicht, welche die Kommunikation mit den Clients verwaltet und die Services aufruft.
        \item Die Service-Schicht, welche Funktionen des \acrshort{lsp}s in Services implementiert.
    \end{enumerate}

    In den folgenden Abschnitten werden der Aufbau, die Aufrufe und die Funktionen dieser Schichten erläutert.
    \subsection{Das \acrfull{lsp}}\label{subsec:das-acrfull{lsp}}\hypertarget{lsp-tech}
    % LSP Protokoll ist modular
    % Verschiedene Packages aufzählen
    Das \acrshort{lsp} wurde von Microsoft für die Verwendung in Visual Studio Code entwickelt. % TODO Quelle
    Es ermöglicht die Funktionen von Plugins über ein Protokoll zu transportieren. \\
    Das Protokoll nutzt JSON-RPC.
    Wie Nachrichten übermittelt werden, wird im Abschnitt \nameref{subsec:server-implementierung} beschrieben.
    \subsubsection{Grundlegende Nachrichten}
%! suppress = MissingLabel
    Im \acrshort{lsp} basieren alle Nachrichten auf dem Message-Interface.
    Deshalb beinhaltet jede Nachricht die JSON-RPC-Version auf der sie basiert.
    \begin{lstlisting}[language=Typescript,label={lst:lstlisting}]
interface Message {
	jsonrpc: string;
}
    \end{lstlisting}
    Die Nachrichten gehören zusätzlich zu einem der folgenden Typen:
    \paragraph{Anfragen}\footnotesize{Request-Message\\}
    \begin{lstlisting}[language=Typescript]
interface RequestMessage extends Message {

	/**
	 * The request id.
	 */
	id: integer | string;

	/**
	 * The method to be invoked.
	 */
	method: string;

	/**
	 * The method's params.
	 */
	params?: array | object;
}
    \end{lstlisting}
    Eine Anfrage wird genutzt, um das Ergebnis einer Methode anzufragen.\\
    Der Type der Parameter wird von der Methode festgelegt.
    Die Antwort wird zu der Anfrage mithilfe der ID zugeordnet.
    Diese ID wird von jedem Teilnehmer hochgezählt.

    \paragraph{Antwort}{\footnotesize Response-Message}\\
    \begin{lstlisting}[language=Typescript]
interface ResponseMessage extends Message {
	/**
	 * The request id.
	 */
	id: integer | string | null;

	/**
	 * The result of a request. This member is REQUIRED on success.
	 * This member MUST NOT exist if there was an error invoking the method.
	 */
	result?: LSPAny;

	/**
	 * The error object in case a request fails.
	 */
	error?: ResponseError;
}
    \end{lstlisting}
    Antworten werden immer nach einer Anfrage geschickt, selbst bei einem Fehler.\\
    Die meisten \acrshort{lsp}-Clients geben dem Server für die Antwort 5 Sekunden Zeit.\\
    Die ID beinhaltet die ID aus der Anfrage.\\
    Das Ergebnis(`result') existiert immer bei einer erfolgreichen Durchführung der Methode.
    Soll kein Wert zurückgegeben werden, so wird beim Ergebnis der Wert ``null'' gesetzt.\\
    Bei einem Fehler während der Ausführung der Methode muss der Fehler(`error') in der Antwort befüllt werden.
    \begin{lstlisting}[language=Typescript]
interface ResponseError {
	/**
	 * A number indicating the error type that occurred.
	 */
	code: integer;

	/**
	 * A string providing a short description of the error.
	 */
	message: string;

	/**
	 * A primitive or structured value that contains additional
	 * information about the error. Can be omitted.
	 */
	data?: LSPAny;
}
    \end{lstlisting}
    Der beinhaltet zwei wichtige Elemente: den Error-Code und die Error-Nachricht.
    Die Error-Codes sind vordefiniert vom Protokoll.\cite{response}
    Die Nachricht ist frei wählbar, sollte jedoch dem Nutzer erklären, wodurch der Fehler entstand.\\
    Es können zusätzliche Daten übermittelt werden.
    Jedoch ist das Format nicht definiert.
    Es bietet sich nur an dieses Element zu nutzen, wenn sowohl Server als auch Client selbst implementiert wurden.

    \paragraph{Benachrichtigungen}{\footnotesize Notification-Message}\\
\begin{lstlisting}[language=Typescript]
interface NotificationMessage extends Message {
	/**
	 * The method to be invoked.
	 */
	method: string;

	/**
	 * The notification's params.
	 */
	params?: array | object;
}
\end{lstlisting}
    Benachrichtigungen übermitteln Daten, ohne eine Antwort zu erwarten.
    Sie werden für z.B.\ den Abbruch einer Anfrage oder dem Übermitteln der aktuellen Fehler genutzt.\\
    Das Datenmodell einer Benachrichtigung unterscheidet sich von einer Anfrage nur durch die fehlende ID.


    \subsubsection{Der \acrshort{lsp}-Kommunikation-Lebenszyklus}
    Die Kommunikation eines Clients mit einem Server folgt einem Ablauf, welcher den Anfang und das Ende der Kommunikation definiert.
    Der Start eines Vorgangs im Lebenszyklus wird immer vom Client gestartet.
    %! suppress = MissingLabel
    \begin{center}
        \begin{sequencediagram}
            \newthread{c}{Client}{}
            \newthreadShift{s}{Server}{25em}

            \begin{sdblock}{Initialisierung}{Start der Kommunikation}
                \begin{call}{c}{initialize}{s}{}
                \end{call}
                \mess{s}{initialized}{c}{}
            \end{sdblock}

            \begin{sdblock}{Nutzung des Servers}{Inhalt der Kommunikation}
                \mess{c}{}{s}{}
                \mess{s}{}{c}{}
            \end{sdblock}

            \begin{sdblock}{Beenden des Servers}{Ende der Kommunikation}
                \begin{call}{c}{shutdowm}{s}{}
                \end{call}
                \mess{c}{exit}{s}{}
            \end{sdblock}
        \end{sequencediagram}
    \end{center}
    \paragraph{Initialisierung}\mbox{}\\
    Die Initialisierung umfasst die ersten Nachrichten, nachdem die Transportschicht die Verbindung etabliert hat. \\
    Sie beginnt mit dem Aufruf der Methode `initialize' des Servers.
    In den Parametern des Aufrufs werden die vom Client unterstützten Funktionen des \acrshort{lsp}s übermittelt.
    Der Server antwortet mit der Auswahl aus den vom Client gesendeten Funktionen, die auch der Server unterstützt.
    Die Unterstützung einer Funktion muss keine Entscheidungsfrage sein.
    Server und Client übermitteln auch wie sie Funktionen unterstützen.
    So können Client oder Server kommunizieren, dass sie z.B.\ die Veränderungen an einer Datei und/oder die vollständigen Dateien unterstützen.
    (Für genauere Informationen siehe Abschnitt \nameref{subsubsec:dokumenten-synchronisation})
    \newline
    \newline
    Nachdem die Feinheiten der Kommunikation bekannt sind, beginnt der Server mit den Vorbereitungen, um alle vereinbarten Funktionen verarbeiten zu können.
    Ist diese Vorbereitung abgeschlossen, sendet der Server die `initialized' Benachrichtigung.
    Nun ist der Start der Kommunikation ist erfolgreich abgeschlossen.


    \paragraph{Beenden des Servers}\mbox{}\\
    Wird der \acrshort{lsp}-Server nicht mehr vom Client benötigt, z.B.\ da keine relevanten Dateien mehr geöffnet sind oder die \acrshort{ide}/das Projekt geschlossen wird, so wird die Methode `shutdown' aufgerufen.
    Die Methode erwartet leere Parameter und beendet alle Strukturen für die Verarbeitung der \acrshort{lsp}-Funktionen.
    \\\\
    Sobald der Client die Kommunikation beendet, sendet er eine `exit'-Benachrichtigung.
    Hat der Server vorher eine `shutdown'-Anfrage erfolgreich beantwortet, so soll er mit dem Exit-Code 0 beenden.
    Ansonsten soll er sich mit dem Exit-Code 1 beenden.\\
    Der Exit-Code kann nur vom Client gelesen werden, wenn dieser den Prozess des Servers auch gestartet hat.
    \\\\
    In den folgenden Abschnitten werden die Funktionen die der \acrshort{dmf}-\acrshort{lsp}-Server unterstützt vorgestellt.

    \subsubsection[Anfragen stornieren]{Anfragen stornieren\\ {\textnormal{\footnotesize Cancelation Support (\$/cancelRequest) \cite{cancelation}}}} \label{subsubsec:cancel}
    Der Client kann jederzeit entscheiden, dass das Ergebnis einer Anfrage nicht mehr benötigt wird.
    \begin{lstlisting}[language=Typescript,title=Definition der Parameter \cite{cancelation},label={lst:cancelParams}]
interface CancelParams {
	/**
	 * The request id to cancel.
	 */
	id: integer | string;
}
    \end{lstlisting}
    Die Parameter enthalten die ID der Anfrage, dessen Ergebnis nicht mehr benötigt wird.
    Der Server muss jedoch die Anfrage trotzdem noch beantworten, um dem Ablauf des Protokolls zu folgen.
    \\\\
    Diese Funktion wird im \namref{subsubsec:cancel-service} implementiert.

    \subsubsection[Dokumenten Synchronisation]{Dokumenten Synchronisation\\ {\textnormal{\footnotesize Text Document Synchronization \\ (textDocument/didOpen, textDocument/didChange, textDocument/didClose) \cite{dokumente}}}}\label{subsubsec:dokumenten-synchronisation}
    Damit ein \acrshort{lsp}-Server Aussagen über eine Datei oder ein ganzes Projekt treffen kann, muss der Server den aktuellen Stand der Dateien kennen.
    \\\\
    Während der Initialisierung wird vom Server festgelegt, ob das Öffnen und Schließen von Dateien an den Server übertragen und wie die Bearbeitungen an den Server übertragen werden sollen (gar nicht/komplette Datei/inkrementell).
    Der \acrshort{dmf}-\acrshort{lsp}-Server nutzt sowohl das Öffnen und Schließen der Dateien als auch die inkrementelle Übertragung der Bearbeitungen.
    \\\\
    Die Synchronisation beginnt, mit der Methode `textDocument/didOpen', welche beim Öffnen einer Datei ausgeführt wird.
    \begin{lstlisting}[language=Typescript,title=Definition der Parameter \cite{dokumente}, label=lst:dokumenteParams]
interface DidOpenTextDocumentParams {
	/**
	 * The document that was opened.
	 */
	textDocument: TextDocumentItem;
}
interface TextDocumentItem {
	/**
	 * The text document's URI.
	 */
	uri: DocumentUri;

	/**
	 * The text document's language identifier.
	 */
	languageId: string;

	/**
	 * The version number of this document (it will increase after each
	 * change, including undo/redo).
	 */
	version: integer;

	/**
	 * The content of the opened text document.
	 */
	text: string;
}
    \end{lstlisting}
    Die Parameter der Methode enthalten die \acrfull{uri}, den Inhalt der Datei, die Sprache und die Version.
    Von diesen Parametern sind die \acrshort{uri} und der Inhalt sehr bedeutend.
    Sie bestimmen welcher Inhalt unter welcher \acrshort{uri} vom Server gespeichert und verarbeitet wird.
    \\\\
    Nachdem ein Dokument geöffnet wurde, wird bei jeder Änderung die Methode `textDocument/didChange' aufgerufen.
    Die Parameter enthalten neben der \acrshort{uri} die Änderungen, welche die direkt in die Bearbeitungen der Treesitter-API übersetzt werden können.
    \begin{lstlisting}[language=Typescript, title=Definition der Bearbeitungen (ohne irrelevante Elemente)\cite{dokumente}, label=lst:dokumenteBearbeitung]
export type TextDocumentContentChangeEvent = {
	/**
	 * The range of the document that changed.
	 */
	range: Range;

	/**
	 * The new text for the provided range.
	 */
	text: string;
}
    \end{lstlisting}

    Wird eine Datei geschlossen, können im Server alle Ressourcen für die Datei freigegeben werden.
    Dafür ruft der Client die Methode `textDocument/didClose' auf.
    \\\\
    Die Funktionen für die Dokumenten Synchronization werden im \nameref{subsubsec:file-service} implementiert.

    \subsubsection[Referenzen bestimmen]{Referenzen bestimmen\\ {\textnormal{\footnotesize Go to Declaration \& Find References \\ (textDocument/declaration, textDocument/references) \cite{declaration} \cite{references}}}}\label{subsubsec:referenzen}
    Referenzen sind ein großer Teil des Typsystems des \acrshort{dmf}s.
    Damit diese Referenzen auch nachvollziehbar für die Entwickler*innen sind, bietet das \acrshort{lsp} mehrere Funktionen an.
    \paragraph{Die Deklaration eines Typs} kann mit der Methode `textDocument/declaration' abfragt werden.
    \begin{lstlisting}[language=Typescript, title=Definition der Parameter \cite{declaration}, caption=Definition der Deklarations-Parameter \cite{declaration}, label=lst:declarationParams]
export interface DeclarationParams extends TextDocumentPositionParams,
	WorkDoneProgressParams, PartialResultParams {
}
interface TextDocumentPositionParams {
	/**
	 * The text document.
	 */
	textDocument: TextDocumentIdentifier;

	/**
	 * The position inside the text document.
	 */
	position: Position;
}
    \end{lstlisting}
    Die Deklaration wird als LocationLink als Ergebnis bereitgestellt.
    \begin{lstlisting}[language=Typescript, title=Definition des LocationLink \cite{declaration}, label=lst:locationLink]
interface LocationLink {

	/**
	 * Span of the origin of this link.
	 *
	 * Used as the underlined span for mouse interaction. Defaults to the word
	 * range at the mouse position.
	 */
	originSelectionRange?: Range;

	/**
	 * The target resource identifier of this link.
	 */
	targetUri: DocumentUri;

	/**
	 * The full target range of this link. If the target for example is a symbol
	 * then target range is the range enclosing this symbol not including
	 * leading/trailing whitespace but everything else like comments. This
	 * information is typically used to highlight the range in the editor.
	 */
	targetRange: Range;

	/**
	 * The range that should be selected and revealed when this link is being
	 * followed, e.g the name of a function. Must be contained by the
	 * `targetRange`. See also `DocumentSymbol#range`
	 */
	targetSelectionRange: Range;
}
    \end{lstlisting}
    Ein LocationLink beschriebt einen Bereich in einem, auch vom aktuellem Dokument unterschiedlichem, Dokument.
    Dabei wird zwischen dem kompletten Bereich der Deklaration und dem Bereich welcher automatisch ausgewählt und in einer Auswahl angezeigt werden soll.

    \paragraph{Alle Referenzen zu einem Typ} können mit der Methode `textDocument/references' abgefragt werden.
    Zu den Referenzen gehören die Deklarationen und die Verwendung des Typs in Referenzen, Multireferenzen, Funktionen und Abstraktionen.\\
    Die Parameter unterscheiden sich von den der Deklaration nur im ReferenceContext.
    Dieser beinhaltet die Information, ob die Deklaration in der Antwort enthalten sein soll.
    \begin{lstlisting}[language=Typescript, title=Definition des ReferenceContext \cite{references}, label=lst:referenceContext]
export interface ReferenceContext {
	/**
	 * Include the declaration of the current symbol.
	 */
	includeDeclaration: boolean;
}
    \end{lstlisting}
    Im Ergebnis werden die Referenzen nicht in einem LocationLink zurückgegeben, sondern nur in einer Location.
    Diese Location enthält nur die \acrshort{uri} der Datei und den Bereich der Referenz.
    \begin{lstlisting}[language=Typescript, title=Definition der Location \cite{references}, label=lst:location]
interface Location {
	uri: DocumentUri;
	range: Range;
}
    \end{lstlisting}

    Die Beschreibung der Implementierung beider Methoden befindet sich im Abschnitt \nameref{subsubsec:reference-service}.

    \subsubsection[Hover-Effekt]{Hover-Effekt\\ {\textnormal{\footnotesize Hover (textDocument/hover) \cite{hover}}}}\label{subsubsec:hover}
    Das \acrshort{lsp} bietet die Funktion Informationen über ein Element bereitzustellen, wenn die Entwickler*innen über den Text ``hovern''.
    \\\\
    Während der Initialisierung gibt der Client die Formate an, die er für die Dokumentation unterstützt.
    Das \acrshort{lsp} beinhaltet zwei Formate in der Spezifikation: normaler Text und Mardown.
    \\\\
    Die Parameter der Anfrage erben von den TextDocumentPositionParams (siehe \nameref{lst:declarationParams}).
    Sie enthalten die \acrshort{uri} der Datei und die Position.\\
    Die Dokumentation wird zusammen mit einem optionalen Bereich übermittelt.
    \begin{lstlisting}[language=Typescript, caption=Definition des Hover Ergebnis \cite{hover}, label=lst:hover]
/**
 * The result of a hover request.
 */
export interface Hover {
	/**
	 * The hover's content
	 */
	contents: MarkedString | MarkedString[] | MarkupContent;

	/**
	 * An optional range is a range inside a text document
	 * that is used to visualize a hover, e.g. by changing the background color.
	 */
	range?: Range;
}
export interface MarkupContent {
	/**
	 * The type of the Markup
	 */
	kind: MarkupKind;

	/**
	 * The content itself
	 */
	value: string;
}
export type MarkupKind = 'plaintext' | 'markdown';
    \end{lstlisting}
    Die Implementierung des Hover-Effekts wird im Abschnitt \nameref{subsubsec:hover-service} beschrieben.

    \subsubsection[Faltbereich]{Faltbereich\\ {\textnormal{\footnotesize Folding Ranges (textDocument/foldingRange) \cite{folding}}}}\label{subsubsec:folding}
    Die Möglichkeit den Code in Abschnitte zu unterteilen und diese einfalten zu können, erleichtert die Übersicht in großen Dateien.
    Deshalb definiert das \acrshort{lsp} eine Funktion, um diese Bereiche an die \acrshort{ide} zu übermitteln.
    \\\\
    Während der Initialisierung kann der Client viele Vorgaben und Wünsche an den Server machen.
    Dazu zählen die gewünschte maximale Anzahl der Bereiche,
    ob nur komplette Zeilen gefaltet werden können,
    welche Falttypen unterstützt werden und ob vom Server generierte Zusammenfassungen angezeigt werden können.
    \\\\
    Die Anfrage an den Server beinhaltet nur die \acrshort{uri} der Datei.\\
    Die Antwort des Servers enthält eine Liste mit Faltbereichen.
    Die Faltbereiche decken die komplette Datei ab.
    Jeder Faltbereich enthält zusätzlich zur Startposition und Endposition auch den Falttypen und optional auch eine Zusammenfassung.
    \\\\
    Die Implementierung der Faltbereiche wird im Abschnitt \nameref{subsubsec:folding} beschrieben.

    \subsubsection[Auswahlbereich]{Auswahlbereich\\ {\textnormal{\footnotesize Selection Range (textDocument/selectionRange) \cite{selection}}}}\label{subsubsec:selection}
    Durch die unterschiedlichen Grammatiken aller Programmiersprachen ist eine Verallgemeinerung der Auswahlbereiche in einem Dokument unmöglich.
    Deshalb bietet das \acrshort{lsp} die Möglichkeit diese Bereiche vom Server abzufragen.
    \\\\
    Die Anfrage beinhaltet ein Dokument und verschiedene Positionen, zu denen die Auswahlbereiche erfragt werden.
    Der Vorteil von mehreren Positionen ist die Bündlung der Anfragen für Editoren mit mehreren Eingabemarken(Cursor).
    \begin{lstlisting}[language=Go, title=Auszug aus den Parametern, label=lst:selectionParams]
type SelectionRangeParams struct {
	// TextDocument identifies the document to compute selection ranges for.
	TextDocument protokoll.TextDocumentIdentifier `json:"textDocument"`

	// Positions is an array of positions in the text document for which to compute
	// selection ranges.
	Positions []protokoll.Position `json:"positions"`
}
    \end{lstlisting}
    Auswahlbereiche bilden einen Auszug aus dem \acrshort{ast}.
    Um eine Auswahl zu vergrößern oder zu verkleinern wird der höhere bzw.\ tiefere Auswahlbereich aus der Hierarchie des \acrshort{ast}s benötigt.
    Deshalb beinhaltet die Antwort im \acrshort{lsp} auch die Möglichkeit pro Position eine Kette an Auswahlbereichen zu liefern.
    Diese Kette wird durch das Parent-Attribut gebildet.
    \begin{lstlisting}[language=Go, title=Antwort des Servers, label=lst:selectionResult]
// SelectionRange represents a selection range with its parent selection ranges.
type SelectionRange struct {
	// Range is the actual range of this selection range.
	Range protokoll.Range `json:"range"`

	// Parent is the parent selection range containing this range. Therefore,
	// multiple selection ranges can be encoded into a tree structure.
	Parent *SelectionRange `json:"parent,omitempty"`
}

// SelectionRangeResult represents the result of a selection range request.
// It's an array of SelectionRange objects, one for each position in the request.
type SelectionRangeResult []SelectionRange
    \end{lstlisting}
    Die Implementierung der Auswahlbereiche wird im Abschnitt \nameref{subsubsec:selection-service} beschrieben.

    \subsubsection[Semantische Tokens]{Semantische Tokens\\ {\textnormal{\footnotesize Semantic Tokens (textDocument/semanticTokens/full) \cite{semantic}}}}\label{subsubsec:semantic}
    Um ein schnelles Verständnis einer Datei zu ermöglichen, ist die Einfärbung der Syntax und Semantik wichtig.
    Dafür stellt das \acrshort{lsp} die Möglichkeit bereit semantische Tokens/Symbole zu übermitteln.\\
    Ein Token bezieht sich immer auf einen Bereich im Sourcecode und übermittelt einen Tokentyp und eine Auswahl der Tokenmodifikatoren.
    Die Tokentypen und Tokenmodifikatoren werden während der Initialisierung übermittelt.
    \\\\
    Ein Client kann Anfragen für die semantischen Token an den Server stellen.
    Für das DMF wurde nur die Methode `textDocument/semanticTokens/full' welche alle semantischen Token für eine Datei generiert beachtet.
    \paragraph{Die Codierung des semantischen Token}\label{par:semantic-code}\mbox{}\\
    Wenn die neuen semantischen Tokens übermittelt werden, werden die Tokens mithilfe einer Zahlenfolge codiert.
    Dies führt zu einer starken Komprimierung des Ergebnisses, welche besonders relevant für diese Methode des \acrshort{lsp}s ist, da das Ergebnis besonders viele Daten beinhaltet.\\
    Die Einträge der Zahlenfolge werden nach dem folgenden Schema codiert:
    \begin{center}
        \begin{tabular}{| c | c | m{21.5em} |}
            \hline
            \makecell{Index in der\\ Zahlenfolge\\für Token mit \\Index i} & Name & Erklärung \\
            \hline
            5*i & deltaLine & Die Zeilen zwischen dem letzten Token und diesem Token. \\
            \hline
            5*i+1 & deltaStart & Die Zeichen zwischen dem letzten Token und diesem Token.
            Relativ zu 0, falls der aktuelle Token in einer neuen Zeile ist. \\
            \hline
            5*i+2 & length & Die Länge des Tokens. \\
            \hline
            5*i+3 & tokenType & Index des Typs des Tokens in der Semantik Token Typ Legende. \\
            \hline
            5*i+4 & tokenModifiers & Zahl deren Bits als Wahrheitswerte für jeden Modifikator aus der Legende der Semantik Token Modifikatoren.
            Der erste Bit (0b00000001) steht dabei für den ersten Modifikator. \\
            \hline
        \end{tabular}
    \end{center}
    Die Implementierung der semantischen Tokens wird im Abschnitt \nameref{subsubsec:semantic-service} beschrieben.

    \subsubsection[Diagnosen]{Diagnosen\\ {\textnormal{\footnotesize Publish Diagnostics (textDocument/publishDiagnostics) \cite{diagnostics}}}}\label{subsubsec:diagnostics}
    Um Fehler, Warnungen, Informationen und Hinweise den Entwickler*innen anzeigen zu können bietet das \acrshort{lsp} die Möglichkeit Diagnosen zu übermitteln.
    Hierbei ist die Besonderheit, dass nur der Server weiß, ob und wann die Diagnosen einer Datei sich verändern.
    Deshalb bietet das \acrshort{lsp} die Möglichkeit, dass der Server Benachrichtigungen an den Client mit den Diagnosen sendet.
    \\\\
    Während der Initialisierung kann der Client (neben der Unterstützung von Feinheiten der Spezifikation) angeben, ob er Diagnosen-Tags (eng.\ diagnostic tag) unterstützt.
    Diese Tags differenzieren die Diagnosen, wie die semantischen Modifikatoren die semantisch Tokens weiter differenzieren.
    \\\\
    Die Benachrichtigung beinhalten eine Liste mit Diagnosen.
    Jede Diagnose bezieht sich auf einen Bereich im Sourcecode.
    Eine Diagnose kann ein Fehler, eine Warnung, eine Information oder ein Hinweis sein.\\
    Der Unterschied zwischen einer Information und einem Hinweis liegt Bedeutsamkeit der enthaltenen Information.
    Eine Diagnose mit einer Information sollte beim Ermitteln eines Fehlers vor den Hinweisen beachtet werden.\\
    Der Inhalt einer Diagnose setzt sich aus den Feldern `Message' und `Source' zusammen.
    `Message' beschreibt den Fehler und `Source' den Grund.\\
    Es können auch zusätzliche Informationen in einer Diagnose enthalten sein.
    Diese könne andere Stellen im Code erwähnen, die für die Diagnose bedeutend sind.
    \begin{lstlisting}[language=Go, caption=Definition des Inhalts der Benachrichtigung, label=lst:diagnostics-result]
// Diagnostic represents a diagnostic, such as a compiler error or warning
type Diagnostic struct {
	// Range is the range at which the message applies
	Range Range `json:"range"`
	// Severity is the diagnostic's severity. Can be omitted. If omitted it is up to the
	// client to interpret diagnostics as error, warning, info or hint
	Severity *DiagnosticSeverity `json:"severity,omitempty"`
    // Source is a human-readable string describing the source of this diagnostic
	Source string `json:"source,omitempty"`
	// Message is the diagnostic's message. It usually appears in the user interface
	Message string `json:"message"`
	// Tags provides additional metadata about the diagnostic
	Tags []DiagnosticTag `json:"tags,omitempty"`
	// RelatedInformation provides related diagnostic information
	RelatedInformation []DiagnosticRelatedInformation `json:"relatedInformation,omitempty"`
}
// DiagnosticRelatedInformation represents related diagnostic information, such as related diagnostics
type DiagnosticRelatedInformation struct {
	// Location of this related diagnostic information
	Location Location `json:"location"`
	// Message is a message about this related diagnostic information
	Message string `json:"message"`
}
    \end{lstlisting}

    Die Implementierung für die Erstellung der Diagnosen wird im Abschnitt \nameref{subsubsec:diagnostics-service} beschrieben.
    \subsection{Server Implementierung}\label{subsec:server-implementierung}
    % Wie funktioniert JSON-RPC
    % Wie parsed Golang json
    % Wie werden Service Aufgerufen
       TODO
    \subsubsection{Abstraktion der Server-Client-Verbindung}
    Da das \acrshort{lsp} Medium unabhängig ist, muss der Server eine Abstraktion für die Verbindung bereitstellen.
    \begin{lstlisting}[language=Go]
package connect
type Connection interface {
	// WriteMessage Writes Message.
    // May queue the Message the syncronise the Writing
	WriteMessage(message protokoll.Message)

	// WaitForMessage Waits for the next Message
    // and returns the Message or the error.
	// Call to this method blocks execution.
	WaitForMessage() (protokoll.Message, error)

	BlockResponse(id json.RawMessage)
	Close() error
}
    \end{lstlisting}
    Das Interface Connection stellt diese Abstraktion bereit.
    Es wird für jeden Verbindungstyp implementiert.

    % Wie funktioniert die Kommunikation über HTTP
    \subsection{Die \acrshort{lsp}-Services}
    Die Schnittstelle für alle Services zu der Server-Schicht bildet das MethodHandler-Interface:
    \begin{lstlisting}[language=Go]
package service
type MethodHandler interface {
	Initialize(params *initialize.InitializeParams,
                result *initialize.InitializeResult)
	GetMethods() []string
	HandleMethod(message protokoll.Message)
}
    \end{lstlisting}
    Jeder Service implementiert die drei Methoden.
    \begin{enumerate}
        \item \textbf{Initialize} \\
        Der Service liest die Fähigkeiten des Clients und konfiguriert sich selbständig.
        Sollte der Client den Service nicht unterstützen, muss er sich deaktivieren.
        Der Service schreibt seine Fähigkeiten in die Antwort des Servers.
        \item \textbf{GetMethods} \\
        Gibt die Methoden aus dem \acrshort{lsp} zurück für die der Service Meldungen verarbeitet.
        \item \textbf{HandleMethod} \\
        Verarbeite die Nachricht.
    \end{enumerate}


    \subsubsection[FileService]{FileService \secsubtitle{\nameref{subsubsec:dokumenten-synchronisation}}}
    \label{subsubsec:file-service}
    Der FileService ist die Schnittstelle zwischen den Dateien, den Parsern und den restlichen Services.
    Wenn ein anderer Service auf Dateien, semantische Modell oder den Lookup zugreifen möchte, werden Methoden des FileServices genutzt.
    \begin{lstlisting}[language=Go]
package fileService
type FileService struct {
	handleMap map[string]*fileHandle
	listeners []FileChangeListener
	con       connect.Connection
}
    \end{lstlisting}
    In der ``handleMap'' werden ``fileHandles'' gespeichert.
    Ein FileHandle speichert alle Daten zu einer Datei und wird mit jeder Veränderung aktualisiert.
    \begin{lstlisting}[language=Go]
package fileService
type fileHandle struct {
	FileContent string
	Ast         *tree_sitter.Tree
	Model       *smodel.Model
	LookUp      *smodel.TypeLookUp
	Version     int32
}
    \end{lstlisting}
    Um einen FileHandle zu erzeugen, wird der Inhalt der Datei mithilfe Semantik-Schicht geparst.\\
    Wird der Dateiinhalt geändert, so werden die Änderungen an die Semantik-Schicht übergeben.
    Dort werden die Änderungen zum iterativen Parsen des neuen Dateiinhalts genutzt.
    Abschließend werden der Lookup erzeugt und die semantischen Regeln durchlaufen. \\
    \paragraph{FileChangeListener}
    Es gibt Funktionen im \acrshort{lsp} die nicht durch eingehende Nachrichten ausgelöst werden, sondern nach Dateiänderungen automatisch an den Client übermittelt werden.
    Dafür gibt es im \acrshort{dmf}-\acrshort{lsp}-Server die FileChangeListener.
    \begin{lstlisting}[language=Go]
package fileService
type FileChangeListener interface {
	// HandleFileChange gets called when the FileService
    // finishes parsing the File.
    // It may be called in its own routine.
    // Changes to the Parameters are ignored.
	HandleFileChange(file protokoll.DocumentURI, fileContent string,
                    ast *tree_sitter.Tree, model *smodel.Model,
                    lookup smodel.TypeLookUp,
                    errorElements []errElement.ErrorElement,
                    version int32)
}
    \end{lstlisting}
    Der FileService enthält Referenzen zu allen aktiven Listener.
    Nachdem ein FileHandle erstellt oder bearbeitet wurde, werden alle Listener durchlaufen.\\
    Im \acrshort{dmf}-\acrshort{lsp}-Server ist nur ein FileChangeListener implementiert:
    \subparagraph[DiagnosticsService]{Der DiagnosticsService }\label{subsubsec:diagnostics-service}
    (Protokoll im Abschnitt \ref{subsubsec:diagnostics})
    übermittelt die aktuellen Fehler in der Modelldatei an den Client.
    Dafür werden alle ErrorElemente in die Diagnostic Strukturen des \acrshort{lsp}s übersetzt.
    Schließlich werden die Daten mithilfe einer Request-Nachricht für die Methode ``textDocument/publishDiagnostics'' an den Client übermittelt.

    \subsubsection{SemanticTokensService \secsubtitle{\nameref{subsubsec:semantic}}}\label{subsubsec:semantic-service}
    Der SematicTokensService implementiert die Methode für die semantischen Tokens.
    Diese Tokens werden für die Einfärbung des Textes einer Datei nach der Syntax und Semantik genutzt.
    Mit dieser Einfärbung des Sourcecodes können Entwickler*innen schnell ein Verständnis der Datei entwickeln.
    \\\\
    Ein Token bezieht sich immer auf einen Bereich im Sourcecode und übermittelt einen Tokentyp und eine Auswahl der Tokenmodifikatoren.
    Die Tokentypen und Tokenmodifikatoren werden während der Initialisierung übermittelt.
    Dabei ist für die Codierung (siehe \nameref{par:semantic-code}) der Index in den Listen entscheidend. \\
    Für das \acrshort{dmf} wird nur die folgende Auswahl der Tokenmodifikatoren genutzt.
    \begin{center}
        \begin{tabular}{|c|c|}
            1 & declaration \\
            \hline
            2 & definition
        \end{tabular}
    \end{center}
    \paragraph{Die Tokentypen und ihre Verwendung zusammen mit den Tokenmodifikatoren}
    \begin{center}
        \begin{tabular}{|c|c|>{\centering\arraybackslash}m{\mycolwidth}|}
            \hline
            Index & Token Typ & \makecell{Verwendung im DMF \\
                \begin{tabular}{c|c}
                    Tokenmodifikator(-en) & Verwendung
                \end{tabular}}\tabularnewline
            \hline
            0 & namespace & \tablecell{declaration & Für den Namen eines Packages.}\tabularnewline
            \hline
            1 & type & \tablecell{- &
            \makecell[l]{Für das AST-Element ``reftype''.\\Für den Override Wert des Java Typens.}
            }\tabularnewline
            \hline
            2 & class & \tablecell{- & Für den Override Wert der Java Klasse, der Oberklasse und der implementierten Interfaces.}\tabularnewline
            \hline
            3 & enum & \tablecell{ declaration &  Für den Namen eines Enums.}\tabularnewline
            \hline
            4 & interface & \tablecell{ declaration & Für den Namen eines Interfaces.}\tabularnewline
            \hline
            5 & struct & \tablecell{ declaration & Für den Namen eines Structs oder einer Entity.}\tabularnewline
            \hline
            6 & parameter & \tablecell{ declaration & Für die Parameter einer Funktion. }\tabularnewline
            \hline
            7 & variable &
            \tablecell{
                - & Für die Namen der Variablen im Entity Identifier. Für den Override Wert des Java Namens.\\
                \hline
                declaration & Für die Namen von Argumenten, Referenzen und MultiReferenzen.\\
            }\\
            \hline
            8 & property & Platzhalter\tabularnewline
            \hline
            9 & number & \tablecell{ definition & Für alle Zahlenwerte in einer Enum-Konstante.}\tabularnewline
            \hline
            10 & enumMember & \tablecell{declaration& Für den Namen einer Enum-Konstante. }\tabularnewline
            \hline
            11 & function & \tablecell{ declaration & Für den Namen einer Funktion. }\tabularnewline
            \hline
            12 & comment & \tablecell{ - & Für alle Kommentare.}\tabularnewline
            \hline
            13 & keyword & \tablecell{ - & Für alle Keywords.}\tabularnewline
            \hline
            14 & string & \tablecell{ - & Für alle Strings außer den Werten im Override. }\tabularnewline
            \hline
            15 & modifier & Platzhalter\tabularnewline
            \hline
            16 & decorator & \tablecell{ - & Für den Override Wert der Java Annotations. }\tabularnewline
            \hline
        \end{tabular}
    \end{center}
    \paragraph{Generierung der Semantik Tokens}\mbox{}\\
    Die Semantik Tokens werden mithilfe zweier Algorithmen generiert.
    \subparagraph{Mithilfe des \acrshort{ast}s} werden alle \acrshort{ast}-Elemente durchlaufen.
    Werden Elemente erreicht, deren semantischer Token allein am \acrshort{ast} Element bestimmt werden kann, so werden die Token generiert.
    Dazu gehören die meisten semantischen Token.
    \subparagraph{Mithilfe des semantischen Modells} werden die restlichen Token bestimmt.
    Dies ist möglich da die Elemente im semantischen Modell Referenzen zum \acrshort{ast} beinhalten.
    Dazu gehören die Namen der verschiedenen Inhalte, wie z.B.\ von Argumenten.
    Bei diesen Namen wird das gleiche \acrshort{ast}-Element genutzt, wodurch sie nur das semantische Parsen unterscheidbar sind.
    \\\\
    Die semantischen Tokens befinden sich nun in einer Liste mit semantischen Elementen.
    Diese müssen für die Antwort codiert werden.
    \begin{lstlisting}[language=Go, caption=semantisches Element, label=lst:semantic-element]
type semanticElement struct {
	line           uint32
	start          uint32
	length         uint32
	tokenType      uint32
	tokenModifiers uint32
}
    \end{lstlisting}

    \subparagraph{Die Codierung der semantischen Tokens} muss zunächst die generierten Tokens sortieren, da keine Garantie für die richtige Reihenfolge durch die beiden Algorithmen existiert.
    \begin{lstlisting}[language=Go,label={lst:sortSemanticTokens}]
slices.SortFunc(semanticElements, func(a, b *semanticElement) int {
    if a.line == b.line {
        return cmp.Compare(a.start, b.start)
    }
    return cmp.Compare(a.line, b.line)
})
    \end{lstlisting}
    Nach der Sortierung können die Tokens durchlaufen werden.
    \begin{lstlisting}[language=Go]
data := make([]uint32, len(semanticElements)*5)

lastLine := uint32(0)
lastStart := uint32(0)

for i, element := range semanticElements {
    line := element.line
    start := element.start
    length := element.length
    tokenType := element.tokenType
    tokenModifiers := element.tokenModifiers
    if line < lastLine {
        // Tokens must be sorted by line and character
        continue
    }

    if line == lastLine && start < lastStart {
        // Tokens must be sorted by line and character
        continue
    }

    // Calculate delta encoding
    deltaLine := line - lastLine
    deltaStart := uint32(0)
    if line == lastLine {
        deltaStart = start - lastStart
    } else {
        deltaStart = start
    }

    data[i*5] = deltaLine
    data[i*5+1] = deltaStart
    data[i*5+2] = length
    data[i*5+3] = tokenType
    data[i*5+4] = tokenModifiers

    lastLine = line
    lastStart = start
}
    \end{lstlisting}
    Beim Durchlaufen wird ein Integer-Slice erstellt. \\
    Für jeden Token werden die 5 Zahlen nach dem Protokoll hinzugefügt. \\
    Überschneiden sich Token oder sind nicht in der richtigen Reihenfolge werden die Token ignoriert. \\
    Die aktuelle Zeile und Spalte im Text wird nach jedem Token aktualisiert.

    \subsubsection[SelectionRangeService]{SelectionRangeService \secsubtitle{\nameref{subsubsec:selection}}}\label{subsubsec:selection-service}
    Der SelectionRangeService implementiert die \acrshort{lsp}-Methode ``textDocument/selectionRange''.
    Diese wird dafür genutzt, dass bei der Auswahl immer der richtige Text ausgewählt wird. \\
    Die Bereiche werden im Service mithilfe des \acrshort{ast}s berechnet.
    \begin{lstlisting}[language=Go]
package selectionRangeService
func (s *SelectionRangeService) computeSelectionRangeForPosition(
        content fileService.FileContent,
        position protokoll.Position) *selectionRange.SelectionRange {
	finder := util.NewNodeFinder([]byte(content.Content))
	node := finder.FindSmallestNodeAroundPosition(content.Ast, position)
	var currentRange *selectionRange.SelectionRange
	for node != nil {
		newRange := &selectionRange.SelectionRange{
			Range: protokoll.ToRange(node.Range()),
		}
		newRange.Parent = currentRange
		currentRange = newRange

		node = node.Parent()
	}
	return currentRange
}
    \end{lstlisting}
    Es wird zunächst das kleinste Element(das ``Blatt'' des Baums) des \acrshort{ast}s für die Position Code bestimmt.\\
    Nun wird durch die Schichten des \acrshort{ast}s bis zur Wurzel iteriert.
    Bei jedem Element eine neue ``SelectionRange'' Instanz  angelegt.
    Dieses ``SelectionRange'' enthält immer den Bereich und eine Referenz zu der vorherigen ``SelectionRange''.
    Durch die Referenz wird die Baum-Struktur auch im Ergebnis übermittelt und es müssen weniger Anfragen an den Server gesendet werden.\\

    Ein Request kann mehrere Positionen enthalten.
    Deshalb wird der Algorithmus für jede Position ausgeführt.

    \subsubsection[FoldingService]{FoldingService \secsubtitle{\nameref{subsubsec:folding}}}\label{subsubsec:folding-service}
    Der FoldingService stellt die Methode `textDocument/foldingRange', für die Übermittlung der faltbaren Bereiche, bereit.
    Es werden drei verschiende Bereicharten berechnet: PackageElemente, Kommentare und der Import-Block.
    \subparagraph{Für die PackageElemente} werden die \acrshort{ast}-Nodes des Elements durchlaufen.
    Es wird immer der Bereich, welcher von den geschweiften Klammern umschlossen wird, gefaltet.
    Deshalb werden die auch diese Nodes beim Durchlaufen gesucht.
    \begin{lstlisting}[language=Go, caption=Suche nach Start- und Ende-Node des Faltbereichs eines PackageElements, label=lst:foldPackageElement]
cursor.GotoFirstChild()
for {
    if cursor.Node().GrammarName() == "{" {
        startNode = cursor.Node()
    }
    if cursor.Node().GrammarName() == "}" {
        endNode = cursor.Node()
    }
    if !cursor.GotoNextSibling() {
        break
    }
}
    \end{lstlisting}
    Mithilfe diese Nodes kann auf die Zeilen und Spalten beider Positonen zugegriffen werden.
    Damit die Klammern auch noch in der \acrshort{ide} angezeigt werden, wird der Startzeichenindex (Start-Spalte) um 1 erhöht und der Endzeichenindex (End-Spalte) um 1 gesenkt.

    \subparagraph{Für die Kommentare} wird die Query-Funktion von Treesitter genutzt.
    \begin{lstlisting}[capture=Die Query für alle Kommentare, label=lst:commentQuery]
(comment_block) @cb
    \end{lstlisting}
    Die Ergebnisse einer Query werden in der Treesitter-\acrshort{api} QueryMatches genannt.
    Für diese Query enthalten sie alle `comment_block' Nodes im \acrshort{ast}.
    Durch die Ergebnisse wird iteriert und für jeden QueryMatch ein Faltbereich erstellt.
    Dabei wird zwischen einzeiligen und mehrzeiligen Kommentaren unterschieden, die Position unterschiedlich interpretiert werden müssen.
    Einzeilige Kommentare werden nicht in jeder \acrshort{ide} gut verarbeitet, deshalb können sie über die Argumente ausgeschaltet werden.
    \begin{lstlisting}[language=Go, caption=Auszug aus der Bestimmung der Faltbereiche für die Kommentare, label=lst:foldingCommentsFor]
queryCursor := tree_sitter.NewQueryCursor()
captures := queryCursor.Captures(f.kommentarQuery,
                            root.RootNode(), nil)
for match, index := captures.Next(); match != nil;
        match, index = captures.Next() {
    node := match.Captures[index].Node
    startPos := node.StartPosition()
    endPos := node.EndPosition()

    if startPos.Row != endPos.Row {
        // Mehrzeilige Kommentare
    }else if !args.DisableSingleLineCommentsFolding{
        // Einzeilige Kommentare
    }
}
    \end{lstlisting}
    \textbf{Bei allen Kommentaren} liegt das Ende im Ergebnis der Query in der nächsten Zeile.
    Der Faltbereich soll jeden am Ende der Kommentarzeile enden.
    Deshalb wird die Endposition verschoben.\\
    \textbf{Bei mehrzeiligen Kommentaren} müssen Startzeichenindex und Endzeichenindex anhand von unterschiedlichen Zeilen bestimmt werden.
    Dafür muss der Inhalt des Kommentars in Zeilen aufgeteilt werden.
    Die erste und letzte Zeile werden für die Indexe genutzt.
    Für die Zusammenfassung wird die \\
    \textbf{Bei einzieligen Kommentaren} könen die Indexe anhand der einen Zeile bestimmt werden.

    \subparagraph{Für den Import-Block} wird die Node des Import-Blocks aus dem \acrshort{ast} genutzt.
    Diese enthält jedoch alle Zeilen, ab dem ersten Import-Statement bis zum ersten PackageElement.
    Deshalb werden die Leerzeilen am Ende des Import-Blocks herrausgefiltert.
    \begin{lstlisting}[language=Go, caption=Filterung der leeren Zeilen, label=lst:filterImportFolding]
var endPos tree_sitter.Point
for {
    if cursor.Node().GrammarName() == "import_block" {
        importBlock = cursor.Node()
        cursor.GotoLastChild()
        endPos = cursor.Node().EndPosition()
        text := cursor.Node().Utf8Text([]byte(content))
        split := strings.Split(text, "\n")
        length := len(split)
        for i := range split {
            s := split[length-i-1]
            if strings.ContainsFunc(s, func(r rune) bool {
                switch r {
                case ' ', '\n':
                    return false
                default:
                    return true
                }
            }) {
                endPos.Column = uint(len(split[length-i-1]))
            } else {
                endPos.Row--
            }
        }
        break
    }
    if !cursor.GotoNextSibling() {
        break
    }
}
    \end{lstlisting}

    \subsubsection[ReferenceService]{ReferenceService \secsubtitle{\nameref{subsubsec:referenzen}}}\label{subsubsec:reference-service}
    Um zwischen den Referenzen und den Deklarationen in der \acrshort{ide} in der Datei springen zu können, implementiert der ReferenzService die Methoden `textDocument/references' und `textDocument/declaration'. \\
    Die Parameter für beide Methoden enthalten das Textdokument und die Position im Dokument.
    Um die Referenz zu finden, wird der \acrshort{ast} vom Blatt an der Position zur Wurzel durchlaufen.
    Dabei werden für folgende Node-Typen die erste Node gespeichert.
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            \acrshort{ast}-Node Namen & Verwendung \\
            \hline
            reftype & Referenzen, Multireferenzen oder Parameter \\
            \hline
            identifier & Namen von Variablen oder Funktionen\\
            \hline
            \makecell{package_block, struct_block, enum_block,\\entity_block, interface_block}& PackageElemente\\
            \hline
        \end{tabular}
    \end{center}
    Mithilfe dieser Nodes kann der Name für den LookUp der PackageElemente und der Name des NamedElements innerhalb des PackageElements bestimmt werden.

    \paragraph{Referenzen}\mbox{}\\
    Nachdem das PackageElement und der Name bestimmt wurden, wird unterschieden ob es sich um einen Typ oder um eine Variable handelt.
    \\
    Für die \textbf{Variablen} wird das aktuelle Element und alle SubElemente (Elemente durch Abstraktion) durchsucht.
    In den Elementen wird nach der Variable über den NamendElemente-LookUp und in dem EntityIdentifier gesucht.
    \\
    Für die Suche nach \textbf{Typ}-Referenzen müssen alle PackageElemente durchsucht werden.
    In den PackageElementen werden Referenzen, Multireferenzen, Parameter und die Abstraktion durchsucht.

    \paragraph{Deklarationen}\mbox{}\\
    Auch bei den Deklarationen wird zwischen Typen und Variablen unterschieden. \\
    Für die \textbf{Variablen} wird das Element und die SubElemente durchsucht.
%    TODO erklären
        Für die \textbf{Typen} wird ???

    \subsubsection[HoverService]{HoverService \secsubtitle{\nameref{subsubsec:hover}}}\label{subsubsec:hover-service}
    Der HoverService lässt die Entwickler*innen Zusammenfassungen für jedes Element aufrufen.
    Um zu bestimmen, welche Zusammenfasssung zu welchen Element übermittelt werden muss, wird zu Beginn jeder Hover-Anfrage die kleinsten Nodes verschiedener Typen bestimmt.
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Zusammenfassung & \acrshort{ast}-Node-Typen \\
            \hline
            Variable & arg_block, ref_block, multi_block \\
            \hline
            EntityIdentifier & identifier_statement\\
            \hline
            Konstante & enum_constant \\
            \hline
            Kommentar & comment_block \\
            \hline
            PackageElement & \makecell{package_block, struct_block, enum_block,\\entity_block, interface_block} \\
            \hline
            Import & import_statement\\
            \hline
            Model Deklaration & model_declaration \\
            \hline
            DMF Deklaration & dmf_declaration \\
            \hline
        \end{tabular}
    \end{center}

    
    \paragraph{Das Generieren der Zusammenfassungen} folgt für jede Zusammenfassung dem gleichen Ablauf.
    Zuerst werden anhand der \acrshort{ast}-Nodes die Elemente aus dem semantischen Modell bestimmt.
    Aus diesen Elementen wird eine spezifische Datenstruktur erstellt.
    Mithilfe dieser Datenstruktur kann das jeweilige Template ausgeführt werden.
    \paragraph{Nutzung von Golang-Templates}\mbox{}\\
    Die Standard Bibliothek von Golang bietet eine Template-Engine das Generieren von Texten genutzt wird.
    Die \acrshort{api} besteht dabei aus 3 Komponenten: Templates, Funktionen und Datenstrukturen.
    \begin{lstlisting}[language=Go, caption=Ablauf der Template-\acrshort{api}, label=lst:template]
// Inkludierung der Templates
//go:embed template/*
var tmplFiles embed.FS

// Vorbereiten der Templates
templates = template.Must(template.New("").
            Funcs(funcMap).
            ParseFS(tmplFiles, "template/*"))

// Generieren mit Templates
buffer := bytes.NewBuffer(make([]byte, 0))
err := templates.ExecuteTemplate(buffer, "variable", data)
return buffer.String()
    \end{lstlisting}
    \textbf{Die Templates} werden in eigenen Dateien abgelegt.
    Mithilfe der Golang-Embeded-\acrshort{api} werden diese Dateien in die ausführbare Datei kopiert und können während der Ausführung ausgelesen werden.\\
    Ein Template wird immer mit einer Datenstruktur aufgerufen.
    Innerhalb eines Templates werden Kontrollstrukturen und Zugriffe auf die Datenstruktur innerhalb von Statements mit `\{\{' und `\}\}' gekennzeichnet.
    Statements in Templates folgen einer simplifierzierten Golang Syntax.
    Das Ergebnis nach ihrer Evaluirung wird in das Ergebnis eingefügt.
    Die größte Simplifizierung sind die Blöcke der Kontrollstrukturen.
    Die Beginnen immer mit einem Statement in der Syntax des jeweiligen Keywords und enden mit dem `\{\{end\}\}'-Statement.\\
    Ein Template wird definiert mit dem Define-Statement (`\{\{define "name"\}\}').
    Der Name im Statement wird später zum Aufrufen des Templates genutzt. \\
    Die Übergebene Datenstruktur wird immer mit `.' adressiert.
    So kann eine Variable der Datenstruktur mithilfe von `\{\{.Variablenname\}\}' eingefügt werden.
    Es ist auch möglich lokale Variablen zu definieren, z.B. `\{\{\$importSlice := getImports .\}\}'.
    Ein Name einer lokalen Variable beginnt immer mit dem Zeichen \$.\\
    Funktionen werden ohne Klammern aufgerufen, jedoch können Klammern zur Abgrenzung der Parameter verschiedener Funktionen genutzt werden.
    Das Statement `ne (len \$importSlice) 0' wird zu einem Wahrheitswert evaluieren.
    Der Aufruf der Funktion `len' befindet sich in Klammern sodass das Ergebnis als ein Parameter der Funktion `ne' verwendet wird.\\
    Mithilfe von `if' und `range' Statements kann der Ablauf eines Templates gesteuert werden.
    Ein `if'-Statement funktioniert als Kontrollstruktur die einen Teil des Templates abhängig von einer Bedingung ausführt.
    Es kann mit einem `else'-Statement erweitert werden.
    Ein `range'-Statement übernimmt die Funktion der Schleifen.
    Es wird immer durch eine Slice iteriert, z.B. `\{\{range \$index, \$use := .Uses\}\}'.\\
    Es können andere Templates aufgerufen werden.
    Dabei kann nur ein Parameter(=eine Datenstruktur) übergeben werden, weshalb häufig Methoden mehrere Parameter in eine Datenstruktur kombinieren.
    Ein Aufruf Statement enthält neben dem Parameter auch den Namen des Templates: `\{\{template "parameter" \$element\}\}'.
    \\
    \textbf{Die Funktionen} werden in Go geschrieben.
    Eine Map dient zum Aufruf der Funktionen während der Generationen.
    Zwischen Funktionen, Templates und Datenstrukturen wird während der Kompilierung und der Vorbereitung der Templates keine Typ-Überprüfung durchgeführt.
    Besitzen die Parameter während der Generation die falschen Typen, wird die Generation mit einem Fehler abgebrochen.\\
    Funktionen besitzen keine Referenzen zum Kontext indem die Generation gestartet wurde.
    Deshalb bleiben nur noch die globalen Elemente und die Parameter.
    Globale Elemente können jedoch diesen Kontext auch nicht speichern, wenn die Generation parallel ausgeführt wird.
    Somit wird jeder erfordlicher Kontext in den Parametern übergeben.
    \\
    \textbf{Die Datenstrukturen} werden normal im Go-Code definiert.
    Sie enthalten neben den Daten aus dem semantischen Modell auch den evtuellen Kontext für den Aufruf für eine Funktion oder bündeln Parameter für den Aufruf eines Templates.
    \\
    \textbf{Bei der Generation} wird ein Writer, der Name des Templates und die Datenstruktur übergeben.
    Das Writer-Interface bietet eine Abstraktion, um Ziel und Implementierungs unabhängig Schreibvorgänge abbilden zu können.
    Um die Zusammenfassung später als String übergeben zu können, wird ein Buffer genutzt.
    \\\\
    Die verschiedenen Zusammenfassungen werden im Abschnitt \nameref{subsubsec:hover-use} beschrieben.

    \subsubsection[CancelService]{CancelService \secsubtitle{\nameref{subsubsec:cancel}}}\label{subsubsec:cancel-service}
    Der CancelService wird zum Abbruch von nicht mehr benötigten anfragen genutzt.
    Um eine Abstraktion über alle Services zu ermöglichen, wird der Abbruch direkt in der Abstraktion der Verbindung implementiert.
    Innerhalb der Verbindung wird gepsichert, ob eine Antwort für eine Anfrage versendet werden soll.
    Wurde die Antwort vom CancelService blockiert, so wird die Antwort ignoriert.
    Um zu identifizieren, welche Antworten blockiert wurden, wird die ID der Anfrage genutzt.
    Diese wird auch in den Parametern der Abbruch-Anfrage übergeben.


\end{document}